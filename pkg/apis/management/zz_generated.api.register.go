// Code generated by generator. DO NOT EDIT.

package management

import (
	"context"
	"fmt"

	configv1alpha1 "github.com/kiosk-sh/kiosk/pkg/apis/config/v1alpha1"
	tenancyv1alpha1 "github.com/kiosk-sh/kiosk/pkg/apis/tenancy/v1alpha1"
	clusterv1 "github.com/loft-sh/api/pkg/apis/cluster/v1"
	storagev1 "github.com/loft-sh/api/pkg/apis/storage/v1"
	"github.com/loft-sh/api/pkg/managerfactory"
	authorizationv1 "k8s.io/api/authorization/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/apis/meta/internalversion"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apiserver/pkg/registry/generic"
	"k8s.io/apiserver/pkg/registry/rest"
	"sigs.k8s.io/apiserver-builder-alpha/pkg/builders"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type NewRESTFunc func(client client.Client, factory managerfactory.SharedManagerFactory) rest.Storage

var (
	ManagementAnnouncementStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalAnnouncement,
		func() runtime.Object { return &Announcement{} },     // Register versioned resource
		func() runtime.Object { return &AnnouncementList{} }, // Register versioned resource list
		NewAnnouncementREST,
	)
	NewAnnouncementREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAnnouncementRESTFunc(Client, Factory)
	}
	NewAnnouncementRESTFunc  NewRESTFunc
	ManagementClusterStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalCluster,
		func() runtime.Object { return &Cluster{} },     // Register versioned resource
		func() runtime.Object { return &ClusterList{} }, // Register versioned resource list
		NewClusterREST,
	)
	NewClusterREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterRESTFunc(Client, Factory)
	}
	NewClusterRESTFunc              NewRESTFunc
	ManagementClusterConnectStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterConnect,
		func() runtime.Object { return &ClusterConnect{} },     // Register versioned resource
		func() runtime.Object { return &ClusterConnectList{} }, // Register versioned resource list
		NewClusterConnectREST,
	)
	NewClusterConnectREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterConnectRESTFunc(Client, Factory)
	}
	NewClusterConnectRESTFunc    NewRESTFunc
	ManagementClusterRoleStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterRole,
		func() runtime.Object { return &ClusterRole{} },     // Register versioned resource
		func() runtime.Object { return &ClusterRoleList{} }, // Register versioned resource list
		NewClusterRoleREST,
	)
	NewClusterRoleREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterRoleRESTFunc(Client, Factory)
	}
	NewClusterRoleRESTFunc  NewRESTFunc
	ManagementConfigStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalConfig,
		func() runtime.Object { return &Config{} },     // Register versioned resource
		func() runtime.Object { return &ConfigList{} }, // Register versioned resource list
		NewConfigREST,
	)
	NewConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewConfigRESTFunc(Client, Factory)
	}
	NewConfigRESTFunc        NewRESTFunc
	ManagementFeatureStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalFeature,
		func() runtime.Object { return &Feature{} },     // Register versioned resource
		func() runtime.Object { return &FeatureList{} }, // Register versioned resource list
		NewFeatureREST,
	)
	NewFeatureREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewFeatureRESTFunc(Client, Factory)
	}
	NewFeatureRESTFunc     NewRESTFunc
	ManagementKioskStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalKiosk,
		func() runtime.Object { return &Kiosk{} },     // Register versioned resource
		func() runtime.Object { return &KioskList{} }, // Register versioned resource list
		NewKioskREST,
	)
	NewKioskREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewKioskRESTFunc(Client, Factory)
	}
	NewKioskRESTFunc         NewRESTFunc
	ManagementLicenseStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLicense,
		func() runtime.Object { return &License{} },     // Register versioned resource
		func() runtime.Object { return &LicenseList{} }, // Register versioned resource list
		NewLicenseREST,
	)
	NewLicenseREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseRESTFunc(Client, Factory)
	}
	NewLicenseRESTFunc            NewRESTFunc
	ManagementLicenseTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLicenseToken,
		func() runtime.Object { return &LicenseToken{} },     // Register versioned resource
		func() runtime.Object { return &LicenseTokenList{} }, // Register versioned resource list
		NewLicenseTokenREST,
	)
	NewLicenseTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseTokenRESTFunc(Client, Factory)
	}
	NewLicenseTokenRESTFunc                  NewRESTFunc
	ManagementSelfSubjectAccessReviewStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSelfSubjectAccessReview,
		func() runtime.Object { return &SelfSubjectAccessReview{} },     // Register versioned resource
		func() runtime.Object { return &SelfSubjectAccessReviewList{} }, // Register versioned resource list
		NewSelfSubjectAccessReviewREST,
	)
	NewSelfSubjectAccessReviewREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSelfSubjectAccessReviewRESTFunc(Client, Factory)
	}
	NewSelfSubjectAccessReviewRESTFunc   NewRESTFunc
	ManagementSubjectAccessReviewStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSubjectAccessReview,
		func() runtime.Object { return &SubjectAccessReview{} },     // Register versioned resource
		func() runtime.Object { return &SubjectAccessReviewList{} }, // Register versioned resource list
		NewSubjectAccessReviewREST,
	)
	NewSubjectAccessReviewREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSubjectAccessReviewRESTFunc(Client, Factory)
	}
	NewSubjectAccessReviewRESTFunc NewRESTFunc
	ManagementTeamStorage          = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalTeam,
		func() runtime.Object { return &Team{} },     // Register versioned resource
		func() runtime.Object { return &TeamList{} }, // Register versioned resource list
		NewTeamREST,
	)
	NewTeamREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamRESTFunc(Client, Factory)
	}
	NewTeamRESTFunc       NewRESTFunc
	ManagementUserStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalUser,
		func() runtime.Object { return &User{} },     // Register versioned resource
		func() runtime.Object { return &UserList{} }, // Register versioned resource list
		NewUserREST,
	)
	NewUserREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserRESTFunc(Client, Factory)
	}
	NewUserRESTFunc      NewRESTFunc
	InternalAnnouncement = builders.NewInternalResource(
		"announcements",
		"Announcement",
		func() runtime.Object { return &Announcement{} },
		func() runtime.Object { return &AnnouncementList{} },
	)
	InternalAnnouncementStatus = builders.NewInternalResourceStatus(
		"announcements",
		"AnnouncementStatus",
		func() runtime.Object { return &Announcement{} },
		func() runtime.Object { return &AnnouncementList{} },
	)
	InternalCluster = builders.NewInternalResource(
		"clusters",
		"Cluster",
		func() runtime.Object { return &Cluster{} },
		func() runtime.Object { return &ClusterList{} },
	)
	InternalClusterStatus = builders.NewInternalResourceStatus(
		"clusters",
		"ClusterStatus",
		func() runtime.Object { return &Cluster{} },
		func() runtime.Object { return &ClusterList{} },
	)
	InternalClusterMembersREST = builders.NewInternalSubresource(
		"clusters", "ClusterMembers", "members",
		func() runtime.Object { return &ClusterMembers{} },
	)
	NewClusterMembersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterMembersRESTFunc(Client, Factory)
	}
	NewClusterMembersRESTFunc NewRESTFunc
	InternalClusterResetREST  = builders.NewInternalSubresource(
		"clusters", "ClusterReset", "reset",
		func() runtime.Object { return &ClusterReset{} },
	)
	NewClusterResetREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterResetRESTFunc(Client, Factory)
	}
	NewClusterResetRESTFunc                   NewRESTFunc
	InternalClusterVirtualClusterDefaultsREST = builders.NewInternalSubresource(
		"clusters", "ClusterVirtualClusterDefaults", "virtualclusterdefaults",
		func() runtime.Object { return &ClusterVirtualClusterDefaults{} },
	)
	NewClusterVirtualClusterDefaultsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterVirtualClusterDefaultsRESTFunc(Client, Factory)
	}
	NewClusterVirtualClusterDefaultsRESTFunc NewRESTFunc
	InternalClusterConnect                   = builders.NewInternalResource(
		"clusterconnect",
		"ClusterConnect",
		func() runtime.Object { return &ClusterConnect{} },
		func() runtime.Object { return &ClusterConnectList{} },
	)
	InternalClusterConnectStatus = builders.NewInternalResourceStatus(
		"clusterconnect",
		"ClusterConnectStatus",
		func() runtime.Object { return &ClusterConnect{} },
		func() runtime.Object { return &ClusterConnectList{} },
	)
	InternalClusterRole = builders.NewInternalResource(
		"clusterroles",
		"ClusterRole",
		func() runtime.Object { return &ClusterRole{} },
		func() runtime.Object { return &ClusterRoleList{} },
	)
	InternalClusterRoleStatus = builders.NewInternalResourceStatus(
		"clusterroles",
		"ClusterRoleStatus",
		func() runtime.Object { return &ClusterRole{} },
		func() runtime.Object { return &ClusterRoleList{} },
	)
	InternalConfig = builders.NewInternalResource(
		"configs",
		"Config",
		func() runtime.Object { return &Config{} },
		func() runtime.Object { return &ConfigList{} },
	)
	InternalConfigStatus = builders.NewInternalResourceStatus(
		"configs",
		"ConfigStatus",
		func() runtime.Object { return &Config{} },
		func() runtime.Object { return &ConfigList{} },
	)
	InternalFeature = builders.NewInternalResource(
		"features",
		"Feature",
		func() runtime.Object { return &Feature{} },
		func() runtime.Object { return &FeatureList{} },
	)
	InternalFeatureStatus = builders.NewInternalResourceStatus(
		"features",
		"FeatureStatus",
		func() runtime.Object { return &Feature{} },
		func() runtime.Object { return &FeatureList{} },
	)
	InternalKiosk = builders.NewInternalResource(
		"kiosk",
		"Kiosk",
		func() runtime.Object { return &Kiosk{} },
		func() runtime.Object { return &KioskList{} },
	)
	InternalKioskStatus = builders.NewInternalResourceStatus(
		"kiosk",
		"KioskStatus",
		func() runtime.Object { return &Kiosk{} },
		func() runtime.Object { return &KioskList{} },
	)
	InternalLicense = builders.NewInternalResource(
		"licenses",
		"License",
		func() runtime.Object { return &License{} },
		func() runtime.Object { return &LicenseList{} },
	)
	InternalLicenseStatus = builders.NewInternalResourceStatus(
		"licenses",
		"LicenseStatus",
		func() runtime.Object { return &License{} },
		func() runtime.Object { return &LicenseList{} },
	)
	InternalLicenseToken = builders.NewInternalResource(
		"licensetokens",
		"LicenseToken",
		func() runtime.Object { return &LicenseToken{} },
		func() runtime.Object { return &LicenseTokenList{} },
	)
	InternalLicenseTokenStatus = builders.NewInternalResourceStatus(
		"licensetokens",
		"LicenseTokenStatus",
		func() runtime.Object { return &LicenseToken{} },
		func() runtime.Object { return &LicenseTokenList{} },
	)
	InternalSelfSubjectAccessReview = builders.NewInternalResource(
		"selfsubjectaccessreviews",
		"SelfSubjectAccessReview",
		func() runtime.Object { return &SelfSubjectAccessReview{} },
		func() runtime.Object { return &SelfSubjectAccessReviewList{} },
	)
	InternalSelfSubjectAccessReviewStatus = builders.NewInternalResourceStatus(
		"selfsubjectaccessreviews",
		"SelfSubjectAccessReviewStatus",
		func() runtime.Object { return &SelfSubjectAccessReview{} },
		func() runtime.Object { return &SelfSubjectAccessReviewList{} },
	)
	InternalSubjectAccessReview = builders.NewInternalResource(
		"subjectaccessreviews",
		"SubjectAccessReview",
		func() runtime.Object { return &SubjectAccessReview{} },
		func() runtime.Object { return &SubjectAccessReviewList{} },
	)
	InternalSubjectAccessReviewStatus = builders.NewInternalResourceStatus(
		"subjectaccessreviews",
		"SubjectAccessReviewStatus",
		func() runtime.Object { return &SubjectAccessReview{} },
		func() runtime.Object { return &SubjectAccessReviewList{} },
	)
	InternalTeam = builders.NewInternalResource(
		"teams",
		"Team",
		func() runtime.Object { return &Team{} },
		func() runtime.Object { return &TeamList{} },
	)
	InternalTeamStatus = builders.NewInternalResourceStatus(
		"teams",
		"TeamStatus",
		func() runtime.Object { return &Team{} },
		func() runtime.Object { return &TeamList{} },
	)
	InternalTeamClusterRolesREST = builders.NewInternalSubresource(
		"teams", "TeamClusterRoles", "clusterroles",
		func() runtime.Object { return &TeamClusterRoles{} },
	)
	NewTeamClusterRolesREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamClusterRolesRESTFunc(Client, Factory)
	}
	NewTeamClusterRolesRESTFunc NewRESTFunc
	InternalTeamClustersREST    = builders.NewInternalSubresource(
		"teams", "TeamClusters", "clusters",
		func() runtime.Object { return &TeamClusters{} },
	)
	NewTeamClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamClustersRESTFunc(Client, Factory)
	}
	NewTeamClustersRESTFunc NewRESTFunc
	InternalTeamSpacesREST  = builders.NewInternalSubresource(
		"teams", "TeamSpaces", "spaces",
		func() runtime.Object { return &TeamSpaces{} },
	)
	NewTeamSpacesREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamSpacesRESTFunc(Client, Factory)
	}
	NewTeamSpacesRESTFunc NewRESTFunc
	InternalUser          = builders.NewInternalResource(
		"users",
		"User",
		func() runtime.Object { return &User{} },
		func() runtime.Object { return &UserList{} },
	)
	InternalUserStatus = builders.NewInternalResourceStatus(
		"users",
		"UserStatus",
		func() runtime.Object { return &User{} },
		func() runtime.Object { return &UserList{} },
	)
	InternalUserAccessKeysREST = builders.NewInternalSubresource(
		"users", "UserAccessKeys", "accesskeys",
		func() runtime.Object { return &UserAccessKeys{} },
	)
	NewUserAccessKeysREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserAccessKeysRESTFunc(Client, Factory)
	}
	NewUserAccessKeysRESTFunc    NewRESTFunc
	InternalUserClusterRolesREST = builders.NewInternalSubresource(
		"users", "UserClusterRoles", "clusterroles",
		func() runtime.Object { return &UserClusterRoles{} },
	)
	NewUserClusterRolesREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserClusterRolesRESTFunc(Client, Factory)
	}
	NewUserClusterRolesRESTFunc NewRESTFunc
	InternalUserClustersREST    = builders.NewInternalSubresource(
		"users", "UserClusters", "clusters",
		func() runtime.Object { return &UserClusters{} },
	)
	NewUserClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserClustersRESTFunc(Client, Factory)
	}
	NewUserClustersRESTFunc NewRESTFunc
	InternalUserProfileREST = builders.NewInternalSubresource(
		"users", "UserProfile", "profile",
		func() runtime.Object { return &UserProfile{} },
	)
	NewUserProfileREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserProfileRESTFunc(Client, Factory)
	}
	NewUserProfileRESTFunc NewRESTFunc
	InternalUserQuotasREST = builders.NewInternalSubresource(
		"users", "UserQuotas", "quotas",
		func() runtime.Object { return &UserQuotas{} },
	)
	NewUserQuotasREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserQuotasRESTFunc(Client, Factory)
	}
	NewUserQuotasRESTFunc  NewRESTFunc
	InternalUserSpacesREST = builders.NewInternalSubresource(
		"users", "UserSpaces", "spaces",
		func() runtime.Object { return &UserSpaces{} },
	)
	NewUserSpacesREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserSpacesRESTFunc(Client, Factory)
	}
	NewUserSpacesRESTFunc NewRESTFunc
	InternalUserTeamsREST = builders.NewInternalSubresource(
		"users", "UserTeams", "teams",
		func() runtime.Object { return &UserTeams{} },
	)
	NewUserTeamsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserTeamsRESTFunc(Client, Factory)
	}
	NewUserTeamsRESTFunc            NewRESTFunc
	InternalUserVirtualClustersREST = builders.NewInternalSubresource(
		"users", "UserVirtualClusters", "virtualclusters",
		func() runtime.Object { return &UserVirtualClusters{} },
	)
	NewUserVirtualClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserVirtualClustersRESTFunc(Client, Factory)
	}
	NewUserVirtualClustersRESTFunc NewRESTFunc
	// Registered resources and subresources
	ApiVersion = builders.NewApiGroup("management.loft.sh").WithKinds(
		InternalAnnouncement,
		InternalAnnouncementStatus,
		InternalCluster,
		InternalClusterStatus,
		InternalClusterMembersREST,
		InternalClusterResetREST,
		InternalClusterVirtualClusterDefaultsREST,
		InternalClusterConnect,
		InternalClusterConnectStatus,
		InternalClusterRole,
		InternalClusterRoleStatus,
		InternalConfig,
		InternalConfigStatus,
		InternalFeature,
		InternalFeatureStatus,
		InternalKiosk,
		InternalKioskStatus,
		InternalLicense,
		InternalLicenseStatus,
		InternalLicenseToken,
		InternalLicenseTokenStatus,
		InternalSelfSubjectAccessReview,
		InternalSelfSubjectAccessReviewStatus,
		InternalSubjectAccessReview,
		InternalSubjectAccessReviewStatus,
		InternalTeam,
		InternalTeamStatus,
		InternalTeamClusterRolesREST,
		InternalTeamClustersREST,
		InternalTeamSpacesREST,
		InternalUser,
		InternalUserStatus,
		InternalUserAccessKeysREST,
		InternalUserClusterRolesREST,
		InternalUserClustersREST,
		InternalUserProfileREST,
		InternalUserQuotasREST,
		InternalUserSpacesREST,
		InternalUserTeamsREST,
		InternalUserVirtualClustersREST,
	)

	// Required by code generated by go2idl
	AddToScheme = (&runtime.SchemeBuilder{
		ApiVersion.SchemeBuilder.AddToScheme,
		RegisterDefaults,
	}).AddToScheme
	SchemeBuilder      = ApiVersion.SchemeBuilder
	localSchemeBuilder = &SchemeBuilder
	SchemeGroupVersion = ApiVersion.GroupVersion
)

// Required by code generated by go2idl
// Kind takes an unqualified kind and returns a Group qualified GroupKind
func Kind(kind string) schema.GroupKind {
	return SchemeGroupVersion.WithKind(kind).GroupKind()
}

// Required by code generated by go2idl
// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource {
	return SchemeGroupVersion.WithResource(resource).GroupResource()
}

type Analytics struct {
	Endpoint string
	Requests []ResoureRequests
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Announcement struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   AnnouncementSpec
	Status AnnouncementStatus
}

type AnnouncementSpec struct {
}

type AnnouncementStatus struct {
	Announcement string
}

type Authentication struct {
	Password *AuthenticationPassword
	OIDC     *AuthenticationOIDC
}

type AuthenticationOIDC struct {
	IssuerURL      string
	ClientID       string
	ClientSecret   string
	CAFile         string
	UsernameClaim  string
	UsernamePrefix string
	GroupsClaim    string
	GetUserInfo    bool
	GroupsPrefix   string
	Type           string
}

type AuthenticationPassword struct {
	Disabled bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Cluster struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterSpec
	Status ClusterStatus
}

type ClusterAccounts struct {
	Accounts []string
	Cluster  storagev1.Cluster
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterConnect struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterConnectSpec
	Status ClusterConnectStatus
}

type ClusterConnectSpec struct {
	Config          string
	AdminUser       string
	ClusterTemplate Cluster
}

type ClusterConnectStatus struct {
	Failed  bool
	Reason  string
	Message string
}

type ClusterMember struct {
	Info    EntityInfo
	Account *configv1alpha1.Account
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMembers struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Teams []ClusterMember
	Users []ClusterMember
}

type ClusterQuota struct {
	Cluster string
	Owner   *UserOrTeam
	Quota   configv1alpha1.AccountQuota
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterReset struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Kiosk          bool
	RBAC           bool
	VirtualCluster bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterRole struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterRoleSpec
	Status ClusterRoleStatus
}

type ClusterRoleSpec struct {
	Rules           []rbacv1.PolicyRule
	AggregationRule *rbacv1.AggregationRule
}

type ClusterRoleStatus struct {
}

type ClusterSpace struct {
	Cluster         string
	SleepModeConfig *clusterv1.SleepModeConfig
	Owner           *UserOrTeam
	Space           tenancyv1alpha1.Space
}

type ClusterSpec struct {
	storagev1.ClusterSpec
}

type ClusterStatus struct {
	storagev1.ClusterStatus
}

type ClusterVirtualCluster struct {
	Cluster         string
	SleepModeConfig *clusterv1.SleepModeConfig
	VirtualCluster  storagev1.VirtualCluster
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterVirtualClusterDefaults struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Values  string
	Warning string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Config struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ConfigSpec
	Status ConfigStatus
}

type ConfigSpec struct {
	Authentication Authentication
	OIDC           *OIDC
}

type ConfigStatus struct {
}

type CustomerInfo struct {
	Company      string
	Email        string
	FirstName    string
	LastName     string
	AddressLine1 string
	AddressLine2 string
	City         string
	PostalCode   string
	Country      string
	Created      int64
}

type DefaultPaymentMethod struct {
	Card *DefaultPaymentMethodCard
}

type DefaultPaymentMethodCard struct {
	Last4    string
	ExpMonth uint64
	ExpYear  uint64
	Brand    string
	Funding  string
}

type EntityInfo struct {
	Name        string
	DisplayName string
	Username    string
	Email       string
	Subject     string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Feature struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   FeatureSpec
	Status FeatureStatus
}

type FeatureSpec struct {
}

type FeatureStatus struct {
	Enabled bool
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Kiosk struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   KioskSpec
	Status KioskStatus
}

type KioskSpec struct {
	Space            tenancyv1alpha1.Space
	Account          tenancyv1alpha1.Account
	ConfigAccount    configv1alpha1.Account
	AccountQuota     configv1alpha1.AccountQuota
	Template         configv1alpha1.Template
	TemplateInstance configv1alpha1.TemplateInstance
}

type KioskStatus struct {
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type License struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LicenseSpec
	Status LicenseStatus
}

type LicenseInfo struct {
	Announcement   string
	License        string
	ResourceLimits []ResourceLimit
	Features       map[string]bool
	Customer       CustomerInfo
	Subscription   SubscriptionInfo
	Quantity       int64
	Plan           Plan
	Promotions     Promotions
	Analytics      Analytics
	Links          map[string]string
}

type LicenseSpec struct {
}

type LicenseStatus struct {
	Instance string
	Info     LicenseInfo
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseToken struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LicenseTokenSpec
	Status LicenseTokenStatus
}

type LicenseTokenSpec struct {
}

type LicenseTokenStatus struct {
	Token string
}

type OIDC struct {
	Enabled bool
	Clients []OIDCClient
}

type OIDCClient struct {
	Name         string
	ClientID     string
	ClientSecret string
	RedirectURIs []string
}

type Plan struct {
	Price    int64
	Currency string
	Interval string
	Product  PlanProduct
}

type PlanProduct struct {
	Name      string
	UnitLabel string
}

type Promotions struct {
	Trial *TrialPromotion
}

type ResourceLimit struct {
	Group         string
	Version       string
	Kind          string
	Limit         int64
	BlockRequests []ResoureRequests
}

type ResoureRequests struct {
	Verbs      []string
	Group      string
	Resource   string
	Management bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfSubjectAccessReview struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SelfSubjectAccessReviewSpec
	Status SelfSubjectAccessReviewStatus
}

type SelfSubjectAccessReviewSpec struct {
	authorizationv1.SelfSubjectAccessReviewSpec
}

type SelfSubjectAccessReviewStatus struct {
	authorizationv1.SubjectAccessReviewStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SubjectAccessReview struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SubjectAccessReviewSpec
	Status SubjectAccessReviewStatus
}

type SubjectAccessReviewSpec struct {
	authorizationv1.SubjectAccessReviewSpec
}

type SubjectAccessReviewStatus struct {
	authorizationv1.SubjectAccessReviewStatus
}

type SubscriptionInfo struct {
	TrialEnd             int64
	Status               string
	CurrentPeriodEnd     int64
	NextInvoice          int64
	DefaultPaymentMethod *DefaultPaymentMethod
	Created              int64
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Team struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   TeamSpec
	Status TeamStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClusterRoles struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	ClusterRoles []string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClusters struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Clusters []ClusterAccounts
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamSpaces struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spaces []ClusterSpace
}

type TeamSpec struct {
	storagev1.TeamSpec
}

type TeamStatus struct {
	storagev1.TeamStatus
}

type TrialPromotion struct {
	Product     string
	Description string
	Link        string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type User struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   UserSpec
	Status UserStatus
}

type UserAccessKey struct {
	Name              string
	Key               string
	Expires           int64
	CreationTimestamp int64
	Data              map[string]string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserAccessKeys struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Username string
	Keys     []UserAccessKey
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClusterRoles struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	ClusterRoles []string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClusters struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Clusters []ClusterAccounts
}

type UserOrTeam struct {
	User *EntityInfo
	Team *EntityInfo
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserProfile struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	DisplayName string
	Username    string
	Password    string
	Email       string
	Custom      string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserQuotas struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Quotas []ClusterQuota
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserSpaces struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spaces []ClusterSpace
}

type UserSpec struct {
	storagev1.UserSpec
}

type UserStatus struct {
	storagev1.UserStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserTeams struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Teams []storagev1.Team
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserVirtualClusters struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	VirtualClusters []ClusterVirtualCluster
}

//
// Announcement Functions and Structs
//
// +k8s:deepcopy-gen=false
type AnnouncementStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AnnouncementStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AnnouncementList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Announcement
}

func (Announcement) NewStatus() interface{} {
	return AnnouncementStatus{}
}

func (pc *Announcement) GetStatus() interface{} {
	return pc.Status
}

func (pc *Announcement) SetStatus(s interface{}) {
	pc.Status = s.(AnnouncementStatus)
}

func (pc *Announcement) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Announcement) SetSpec(s interface{}) {
	pc.Spec = s.(AnnouncementSpec)
}

func (pc *Announcement) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Announcement) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Announcement) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Announcement.
// +k8s:deepcopy-gen=false
type AnnouncementRegistry interface {
	ListAnnouncements(ctx context.Context, options *internalversion.ListOptions) (*AnnouncementList, error)
	GetAnnouncement(ctx context.Context, id string, options *metav1.GetOptions) (*Announcement, error)
	CreateAnnouncement(ctx context.Context, id *Announcement) (*Announcement, error)
	UpdateAnnouncement(ctx context.Context, id *Announcement) (*Announcement, error)
	DeleteAnnouncement(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAnnouncementRegistry(sp builders.StandardStorageProvider) AnnouncementRegistry {
	return &storageAnnouncement{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageAnnouncement struct {
	builders.StandardStorageProvider
}

func (s *storageAnnouncement) ListAnnouncements(ctx context.Context, options *internalversion.ListOptions) (*AnnouncementList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AnnouncementList), err
}

func (s *storageAnnouncement) GetAnnouncement(ctx context.Context, id string, options *metav1.GetOptions) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) CreateAnnouncement(ctx context.Context, object *Announcement) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) UpdateAnnouncement(ctx context.Context, object *Announcement) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) DeleteAnnouncement(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Cluster Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Cluster
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMembersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterMembers
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterResetList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterReset
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterVirtualClusterDefaultsList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterVirtualClusterDefaults
}

func (Cluster) NewStatus() interface{} {
	return ClusterStatus{}
}

func (pc *Cluster) GetStatus() interface{} {
	return pc.Status
}

func (pc *Cluster) SetStatus(s interface{}) {
	pc.Status = s.(ClusterStatus)
}

func (pc *Cluster) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Cluster) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterSpec)
}

func (pc *Cluster) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Cluster) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Cluster) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Cluster.
// +k8s:deepcopy-gen=false
type ClusterRegistry interface {
	ListClusters(ctx context.Context, options *internalversion.ListOptions) (*ClusterList, error)
	GetCluster(ctx context.Context, id string, options *metav1.GetOptions) (*Cluster, error)
	CreateCluster(ctx context.Context, id *Cluster) (*Cluster, error)
	UpdateCluster(ctx context.Context, id *Cluster) (*Cluster, error)
	DeleteCluster(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterRegistry(sp builders.StandardStorageProvider) ClusterRegistry {
	return &storageCluster{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageCluster struct {
	builders.StandardStorageProvider
}

func (s *storageCluster) ListClusters(ctx context.Context, options *internalversion.ListOptions) (*ClusterList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterList), err
}

func (s *storageCluster) GetCluster(ctx context.Context, id string, options *metav1.GetOptions) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) CreateCluster(ctx context.Context, object *Cluster) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) UpdateCluster(ctx context.Context, object *Cluster) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) DeleteCluster(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// ClusterConnect Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterConnectStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterConnectStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterConnectList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterConnect
}

func (ClusterConnect) NewStatus() interface{} {
	return ClusterConnectStatus{}
}

func (pc *ClusterConnect) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterConnect) SetStatus(s interface{}) {
	pc.Status = s.(ClusterConnectStatus)
}

func (pc *ClusterConnect) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterConnect) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterConnectSpec)
}

func (pc *ClusterConnect) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterConnect) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterConnect) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterConnect.
// +k8s:deepcopy-gen=false
type ClusterConnectRegistry interface {
	ListClusterConnects(ctx context.Context, options *internalversion.ListOptions) (*ClusterConnectList, error)
	GetClusterConnect(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterConnect, error)
	CreateClusterConnect(ctx context.Context, id *ClusterConnect) (*ClusterConnect, error)
	UpdateClusterConnect(ctx context.Context, id *ClusterConnect) (*ClusterConnect, error)
	DeleteClusterConnect(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterConnectRegistry(sp builders.StandardStorageProvider) ClusterConnectRegistry {
	return &storageClusterConnect{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterConnect struct {
	builders.StandardStorageProvider
}

func (s *storageClusterConnect) ListClusterConnects(ctx context.Context, options *internalversion.ListOptions) (*ClusterConnectList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnectList), err
}

func (s *storageClusterConnect) GetClusterConnect(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) CreateClusterConnect(ctx context.Context, object *ClusterConnect) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) UpdateClusterConnect(ctx context.Context, object *ClusterConnect) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) DeleteClusterConnect(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// ClusterRole Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterRoleStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterRoleStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterRoleList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterRole
}

func (ClusterRole) NewStatus() interface{} {
	return ClusterRoleStatus{}
}

func (pc *ClusterRole) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterRole) SetStatus(s interface{}) {
	pc.Status = s.(ClusterRoleStatus)
}

func (pc *ClusterRole) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterRole) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterRoleSpec)
}

func (pc *ClusterRole) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterRole) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterRole) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterRole.
// +k8s:deepcopy-gen=false
type ClusterRoleRegistry interface {
	ListClusterRoles(ctx context.Context, options *internalversion.ListOptions) (*ClusterRoleList, error)
	GetClusterRole(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterRole, error)
	CreateClusterRole(ctx context.Context, id *ClusterRole) (*ClusterRole, error)
	UpdateClusterRole(ctx context.Context, id *ClusterRole) (*ClusterRole, error)
	DeleteClusterRole(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterRoleRegistry(sp builders.StandardStorageProvider) ClusterRoleRegistry {
	return &storageClusterRole{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterRole struct {
	builders.StandardStorageProvider
}

func (s *storageClusterRole) ListClusterRoles(ctx context.Context, options *internalversion.ListOptions) (*ClusterRoleList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleList), err
}

func (s *storageClusterRole) GetClusterRole(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterRole, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRole), nil
}

func (s *storageClusterRole) CreateClusterRole(ctx context.Context, object *ClusterRole) (*ClusterRole, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRole), nil
}

func (s *storageClusterRole) UpdateClusterRole(ctx context.Context, object *ClusterRole) (*ClusterRole, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRole), nil
}

func (s *storageClusterRole) DeleteClusterRole(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Config Functions and Structs
//
// +k8s:deepcopy-gen=false
type ConfigStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ConfigStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ConfigList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Config
}

func (Config) NewStatus() interface{} {
	return ConfigStatus{}
}

func (pc *Config) GetStatus() interface{} {
	return pc.Status
}

func (pc *Config) SetStatus(s interface{}) {
	pc.Status = s.(ConfigStatus)
}

func (pc *Config) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Config) SetSpec(s interface{}) {
	pc.Spec = s.(ConfigSpec)
}

func (pc *Config) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Config) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Config) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Config.
// +k8s:deepcopy-gen=false
type ConfigRegistry interface {
	ListConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConfigList, error)
	GetConfig(ctx context.Context, id string, options *metav1.GetOptions) (*Config, error)
	CreateConfig(ctx context.Context, id *Config) (*Config, error)
	UpdateConfig(ctx context.Context, id *Config) (*Config, error)
	DeleteConfig(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewConfigRegistry(sp builders.StandardStorageProvider) ConfigRegistry {
	return &storageConfig{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageConfig struct {
	builders.StandardStorageProvider
}

func (s *storageConfig) ListConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConfigList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ConfigList), err
}

func (s *storageConfig) GetConfig(ctx context.Context, id string, options *metav1.GetOptions) (*Config, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) CreateConfig(ctx context.Context, object *Config) (*Config, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) UpdateConfig(ctx context.Context, object *Config) (*Config, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) DeleteConfig(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Feature Functions and Structs
//
// +k8s:deepcopy-gen=false
type FeatureStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type FeatureStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type FeatureList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Feature
}

func (Feature) NewStatus() interface{} {
	return FeatureStatus{}
}

func (pc *Feature) GetStatus() interface{} {
	return pc.Status
}

func (pc *Feature) SetStatus(s interface{}) {
	pc.Status = s.(FeatureStatus)
}

func (pc *Feature) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Feature) SetSpec(s interface{}) {
	pc.Spec = s.(FeatureSpec)
}

func (pc *Feature) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Feature) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Feature) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Feature.
// +k8s:deepcopy-gen=false
type FeatureRegistry interface {
	ListFeatures(ctx context.Context, options *internalversion.ListOptions) (*FeatureList, error)
	GetFeature(ctx context.Context, id string, options *metav1.GetOptions) (*Feature, error)
	CreateFeature(ctx context.Context, id *Feature) (*Feature, error)
	UpdateFeature(ctx context.Context, id *Feature) (*Feature, error)
	DeleteFeature(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewFeatureRegistry(sp builders.StandardStorageProvider) FeatureRegistry {
	return &storageFeature{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageFeature struct {
	builders.StandardStorageProvider
}

func (s *storageFeature) ListFeatures(ctx context.Context, options *internalversion.ListOptions) (*FeatureList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*FeatureList), err
}

func (s *storageFeature) GetFeature(ctx context.Context, id string, options *metav1.GetOptions) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) CreateFeature(ctx context.Context, object *Feature) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) UpdateFeature(ctx context.Context, object *Feature) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) DeleteFeature(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Kiosk Functions and Structs
//
// +k8s:deepcopy-gen=false
type KioskStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type KioskStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type KioskList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Kiosk
}

func (Kiosk) NewStatus() interface{} {
	return KioskStatus{}
}

func (pc *Kiosk) GetStatus() interface{} {
	return pc.Status
}

func (pc *Kiosk) SetStatus(s interface{}) {
	pc.Status = s.(KioskStatus)
}

func (pc *Kiosk) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Kiosk) SetSpec(s interface{}) {
	pc.Spec = s.(KioskSpec)
}

func (pc *Kiosk) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Kiosk) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Kiosk) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Kiosk.
// +k8s:deepcopy-gen=false
type KioskRegistry interface {
	ListKiosks(ctx context.Context, options *internalversion.ListOptions) (*KioskList, error)
	GetKiosk(ctx context.Context, id string, options *metav1.GetOptions) (*Kiosk, error)
	CreateKiosk(ctx context.Context, id *Kiosk) (*Kiosk, error)
	UpdateKiosk(ctx context.Context, id *Kiosk) (*Kiosk, error)
	DeleteKiosk(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewKioskRegistry(sp builders.StandardStorageProvider) KioskRegistry {
	return &storageKiosk{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageKiosk struct {
	builders.StandardStorageProvider
}

func (s *storageKiosk) ListKiosks(ctx context.Context, options *internalversion.ListOptions) (*KioskList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*KioskList), err
}

func (s *storageKiosk) GetKiosk(ctx context.Context, id string, options *metav1.GetOptions) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) CreateKiosk(ctx context.Context, object *Kiosk) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) UpdateKiosk(ctx context.Context, object *Kiosk) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) DeleteKiosk(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// License Functions and Structs
//
// +k8s:deepcopy-gen=false
type LicenseStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LicenseStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []License
}

func (License) NewStatus() interface{} {
	return LicenseStatus{}
}

func (pc *License) GetStatus() interface{} {
	return pc.Status
}

func (pc *License) SetStatus(s interface{}) {
	pc.Status = s.(LicenseStatus)
}

func (pc *License) GetSpec() interface{} {
	return pc.Spec
}

func (pc *License) SetSpec(s interface{}) {
	pc.Spec = s.(LicenseSpec)
}

func (pc *License) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *License) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc License) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store License.
// +k8s:deepcopy-gen=false
type LicenseRegistry interface {
	ListLicenses(ctx context.Context, options *internalversion.ListOptions) (*LicenseList, error)
	GetLicense(ctx context.Context, id string, options *metav1.GetOptions) (*License, error)
	CreateLicense(ctx context.Context, id *License) (*License, error)
	UpdateLicense(ctx context.Context, id *License) (*License, error)
	DeleteLicense(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLicenseRegistry(sp builders.StandardStorageProvider) LicenseRegistry {
	return &storageLicense{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLicense struct {
	builders.StandardStorageProvider
}

func (s *storageLicense) ListLicenses(ctx context.Context, options *internalversion.ListOptions) (*LicenseList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseList), err
}

func (s *storageLicense) GetLicense(ctx context.Context, id string, options *metav1.GetOptions) (*License, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) CreateLicense(ctx context.Context, object *License) (*License, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) UpdateLicense(ctx context.Context, object *License) (*License, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) DeleteLicense(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// LicenseToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type LicenseTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LicenseTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseTokenList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []LicenseToken
}

func (LicenseToken) NewStatus() interface{} {
	return LicenseTokenStatus{}
}

func (pc *LicenseToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *LicenseToken) SetStatus(s interface{}) {
	pc.Status = s.(LicenseTokenStatus)
}

func (pc *LicenseToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *LicenseToken) SetSpec(s interface{}) {
	pc.Spec = s.(LicenseTokenSpec)
}

func (pc *LicenseToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *LicenseToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc LicenseToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store LicenseToken.
// +k8s:deepcopy-gen=false
type LicenseTokenRegistry interface {
	ListLicenseTokens(ctx context.Context, options *internalversion.ListOptions) (*LicenseTokenList, error)
	GetLicenseToken(ctx context.Context, id string, options *metav1.GetOptions) (*LicenseToken, error)
	CreateLicenseToken(ctx context.Context, id *LicenseToken) (*LicenseToken, error)
	UpdateLicenseToken(ctx context.Context, id *LicenseToken) (*LicenseToken, error)
	DeleteLicenseToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLicenseTokenRegistry(sp builders.StandardStorageProvider) LicenseTokenRegistry {
	return &storageLicenseToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLicenseToken struct {
	builders.StandardStorageProvider
}

func (s *storageLicenseToken) ListLicenseTokens(ctx context.Context, options *internalversion.ListOptions) (*LicenseTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseTokenList), err
}

func (s *storageLicenseToken) GetLicenseToken(ctx context.Context, id string, options *metav1.GetOptions) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) CreateLicenseToken(ctx context.Context, object *LicenseToken) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) UpdateLicenseToken(ctx context.Context, object *LicenseToken) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) DeleteLicenseToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// SelfSubjectAccessReview Functions and Structs
//
// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfSubjectAccessReviewList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SelfSubjectAccessReview
}

func (SelfSubjectAccessReview) NewStatus() interface{} {
	return SelfSubjectAccessReviewStatus{}
}

func (pc *SelfSubjectAccessReview) GetStatus() interface{} {
	return pc.Status
}

func (pc *SelfSubjectAccessReview) SetStatus(s interface{}) {
	pc.Status = s.(SelfSubjectAccessReviewStatus)
}

func (pc *SelfSubjectAccessReview) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SelfSubjectAccessReview) SetSpec(s interface{}) {
	pc.Spec = s.(SelfSubjectAccessReviewSpec)
}

func (pc *SelfSubjectAccessReview) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SelfSubjectAccessReview) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SelfSubjectAccessReview) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SelfSubjectAccessReview.
// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewRegistry interface {
	ListSelfSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SelfSubjectAccessReviewList, error)
	GetSelfSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SelfSubjectAccessReview, error)
	CreateSelfSubjectAccessReview(ctx context.Context, id *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error)
	UpdateSelfSubjectAccessReview(ctx context.Context, id *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error)
	DeleteSelfSubjectAccessReview(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSelfSubjectAccessReviewRegistry(sp builders.StandardStorageProvider) SelfSubjectAccessReviewRegistry {
	return &storageSelfSubjectAccessReview{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSelfSubjectAccessReview struct {
	builders.StandardStorageProvider
}

func (s *storageSelfSubjectAccessReview) ListSelfSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SelfSubjectAccessReviewList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReviewList), err
}

func (s *storageSelfSubjectAccessReview) GetSelfSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) CreateSelfSubjectAccessReview(ctx context.Context, object *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) UpdateSelfSubjectAccessReview(ctx context.Context, object *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) DeleteSelfSubjectAccessReview(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// SubjectAccessReview Functions and Structs
//
// +k8s:deepcopy-gen=false
type SubjectAccessReviewStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SubjectAccessReviewStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SubjectAccessReviewList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SubjectAccessReview
}

func (SubjectAccessReview) NewStatus() interface{} {
	return SubjectAccessReviewStatus{}
}

func (pc *SubjectAccessReview) GetStatus() interface{} {
	return pc.Status
}

func (pc *SubjectAccessReview) SetStatus(s interface{}) {
	pc.Status = s.(SubjectAccessReviewStatus)
}

func (pc *SubjectAccessReview) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SubjectAccessReview) SetSpec(s interface{}) {
	pc.Spec = s.(SubjectAccessReviewSpec)
}

func (pc *SubjectAccessReview) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SubjectAccessReview) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SubjectAccessReview) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SubjectAccessReview.
// +k8s:deepcopy-gen=false
type SubjectAccessReviewRegistry interface {
	ListSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SubjectAccessReviewList, error)
	GetSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SubjectAccessReview, error)
	CreateSubjectAccessReview(ctx context.Context, id *SubjectAccessReview) (*SubjectAccessReview, error)
	UpdateSubjectAccessReview(ctx context.Context, id *SubjectAccessReview) (*SubjectAccessReview, error)
	DeleteSubjectAccessReview(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSubjectAccessReviewRegistry(sp builders.StandardStorageProvider) SubjectAccessReviewRegistry {
	return &storageSubjectAccessReview{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSubjectAccessReview struct {
	builders.StandardStorageProvider
}

func (s *storageSubjectAccessReview) ListSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SubjectAccessReviewList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReviewList), err
}

func (s *storageSubjectAccessReview) GetSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) CreateSubjectAccessReview(ctx context.Context, object *SubjectAccessReview) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) UpdateSubjectAccessReview(ctx context.Context, object *SubjectAccessReview) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) DeleteSubjectAccessReview(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Team Functions and Structs
//
// +k8s:deepcopy-gen=false
type TeamStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type TeamStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Team
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClusterRolesList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TeamClusterRoles
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClustersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TeamClusters
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamSpacesList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TeamSpaces
}

func (Team) NewStatus() interface{} {
	return TeamStatus{}
}

func (pc *Team) GetStatus() interface{} {
	return pc.Status
}

func (pc *Team) SetStatus(s interface{}) {
	pc.Status = s.(TeamStatus)
}

func (pc *Team) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Team) SetSpec(s interface{}) {
	pc.Spec = s.(TeamSpec)
}

func (pc *Team) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Team) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Team) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Team.
// +k8s:deepcopy-gen=false
type TeamRegistry interface {
	ListTeams(ctx context.Context, options *internalversion.ListOptions) (*TeamList, error)
	GetTeam(ctx context.Context, id string, options *metav1.GetOptions) (*Team, error)
	CreateTeam(ctx context.Context, id *Team) (*Team, error)
	UpdateTeam(ctx context.Context, id *Team) (*Team, error)
	DeleteTeam(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewTeamRegistry(sp builders.StandardStorageProvider) TeamRegistry {
	return &storageTeam{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageTeam struct {
	builders.StandardStorageProvider
}

func (s *storageTeam) ListTeams(ctx context.Context, options *internalversion.ListOptions) (*TeamList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TeamList), err
}

func (s *storageTeam) GetTeam(ctx context.Context, id string, options *metav1.GetOptions) (*Team, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) CreateTeam(ctx context.Context, object *Team) (*Team, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) UpdateTeam(ctx context.Context, object *Team) (*Team, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) DeleteTeam(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// User Functions and Structs
//
// +k8s:deepcopy-gen=false
type UserStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type UserStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []User
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserAccessKeysList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserAccessKeys
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClusterRolesList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserClusterRoles
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClustersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserClusters
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserProfileList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserProfile
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserQuotasList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserQuotas
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserSpacesList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserSpaces
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserTeamsList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserTeams
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserVirtualClustersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserVirtualClusters
}

func (User) NewStatus() interface{} {
	return UserStatus{}
}

func (pc *User) GetStatus() interface{} {
	return pc.Status
}

func (pc *User) SetStatus(s interface{}) {
	pc.Status = s.(UserStatus)
}

func (pc *User) GetSpec() interface{} {
	return pc.Spec
}

func (pc *User) SetSpec(s interface{}) {
	pc.Spec = s.(UserSpec)
}

func (pc *User) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *User) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc User) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store User.
// +k8s:deepcopy-gen=false
type UserRegistry interface {
	ListUsers(ctx context.Context, options *internalversion.ListOptions) (*UserList, error)
	GetUser(ctx context.Context, id string, options *metav1.GetOptions) (*User, error)
	CreateUser(ctx context.Context, id *User) (*User, error)
	UpdateUser(ctx context.Context, id *User) (*User, error)
	DeleteUser(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewUserRegistry(sp builders.StandardStorageProvider) UserRegistry {
	return &storageUser{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageUser struct {
	builders.StandardStorageProvider
}

func (s *storageUser) ListUsers(ctx context.Context, options *internalversion.ListOptions) (*UserList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*UserList), err
}

func (s *storageUser) GetUser(ctx context.Context, id string, options *metav1.GetOptions) (*User, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) CreateUser(ctx context.Context, object *User) (*User, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) UpdateUser(ctx context.Context, object *User) (*User, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) DeleteUser(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}
