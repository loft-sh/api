// Code generated by generator. DO NOT EDIT.

package management

import (
	"context"
	"fmt"

	configv1alpha1 "github.com/loft-sh/agentapi/pkg/apis/kiosk/config/v1alpha1"
	clusterv1 "github.com/loft-sh/agentapi/pkg/apis/loft/cluster/v1"
	agentstoragev1 "github.com/loft-sh/agentapi/pkg/apis/loft/storage/v1"
	auditv1 "github.com/loft-sh/api/pkg/apis/audit/v1"
	storagev1 "github.com/loft-sh/api/pkg/apis/storage/v1"
	"github.com/loft-sh/api/pkg/managerfactory"
	"github.com/loft-sh/apiserver/pkg/builders"
	policyv1beta1 "github.com/loft-sh/jspolicy/pkg/apis/policy/v1beta1"
	authorizationv1 "k8s.io/api/authorization/v1"
	"k8s.io/apimachinery/pkg/apis/meta/internalversion"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apiserver/pkg/registry/generic"
	"k8s.io/apiserver/pkg/registry/rest"
)

type NewRESTFunc func(factory managerfactory.SharedManagerFactory) rest.Storage

var (
	ManagementAnnouncementStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalAnnouncement,
		func() runtime.Object { return &Announcement{} },     // Register versioned resource
		func() runtime.Object { return &AnnouncementList{} }, // Register versioned resource list
		NewAnnouncementREST,
	)
	NewAnnouncementREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAnnouncementRESTFunc(Factory)
	}
	NewAnnouncementRESTFunc NewRESTFunc
	ManagementAppStorage    = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalApp,
		func() runtime.Object { return &App{} },     // Register versioned resource
		func() runtime.Object { return &AppList{} }, // Register versioned resource list
		NewAppREST,
	)
	NewAppREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAppRESTFunc(Factory)
	}
	NewAppRESTFunc           NewRESTFunc
	ManagementClusterStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalCluster,
		func() runtime.Object { return &Cluster{} },     // Register versioned resource
		func() runtime.Object { return &ClusterList{} }, // Register versioned resource list
		NewClusterREST,
	)
	NewClusterREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterRESTFunc(Factory)
	}
	NewClusterRESTFunc                      NewRESTFunc
	ManagementClusterAccountTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterAccountTemplate,
		func() runtime.Object { return &ClusterAccountTemplate{} },     // Register versioned resource
		func() runtime.Object { return &ClusterAccountTemplateList{} }, // Register versioned resource list
		NewClusterAccountTemplateREST,
	)
	NewClusterAccountTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterAccountTemplateRESTFunc(Factory)
	}
	NewClusterAccountTemplateRESTFunc NewRESTFunc
	ManagementClusterConnectStorage   = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterConnect,
		func() runtime.Object { return &ClusterConnect{} },     // Register versioned resource
		func() runtime.Object { return &ClusterConnectList{} }, // Register versioned resource list
		NewClusterConnectREST,
	)
	NewClusterConnectREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterConnectRESTFunc(Factory)
	}
	NewClusterConnectRESTFunc NewRESTFunc
	ManagementConfigStorage   = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalConfig,
		func() runtime.Object { return &Config{} },     // Register versioned resource
		func() runtime.Object { return &ConfigList{} }, // Register versioned resource list
		NewConfigREST,
	)
	NewConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewConfigRESTFunc(Factory)
	}
	NewConfigRESTFunc                           NewRESTFunc
	ManagementDirectClusterEndpointTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDirectClusterEndpointToken,
		func() runtime.Object { return &DirectClusterEndpointToken{} },     // Register versioned resource
		func() runtime.Object { return &DirectClusterEndpointTokenList{} }, // Register versioned resource list
		NewDirectClusterEndpointTokenREST,
	)
	NewDirectClusterEndpointTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDirectClusterEndpointTokenRESTFunc(Factory)
	}
	NewDirectClusterEndpointTokenRESTFunc NewRESTFunc
	ManagementEventStorage                = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalEvent,
		func() runtime.Object { return &Event{} },     // Register versioned resource
		func() runtime.Object { return &EventList{} }, // Register versioned resource list
		NewEventREST,
	)
	NewEventREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewEventRESTFunc(Factory)
	}
	NewEventRESTFunc         NewRESTFunc
	ManagementFeatureStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalFeature,
		func() runtime.Object { return &Feature{} },     // Register versioned resource
		func() runtime.Object { return &FeatureList{} }, // Register versioned resource list
		NewFeatureREST,
	)
	NewFeatureREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewFeatureRESTFunc(Factory)
	}
	NewFeatureRESTFunc                   NewRESTFunc
	ManagementGlobalClusterAccessStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalGlobalClusterAccess,
		func() runtime.Object { return &GlobalClusterAccess{} },     // Register versioned resource
		func() runtime.Object { return &GlobalClusterAccessList{} }, // Register versioned resource list
		NewGlobalClusterAccessREST,
	)
	NewGlobalClusterAccessREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewGlobalClusterAccessRESTFunc(Factory)
	}
	NewGlobalClusterAccessRESTFunc             NewRESTFunc
	ManagementGlobalClusterRoleTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalGlobalClusterRoleTemplate,
		func() runtime.Object { return &GlobalClusterRoleTemplate{} },     // Register versioned resource
		func() runtime.Object { return &GlobalClusterRoleTemplateList{} }, // Register versioned resource list
		NewGlobalClusterRoleTemplateREST,
	)
	NewGlobalClusterRoleTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewGlobalClusterRoleTemplateRESTFunc(Factory)
	}
	NewGlobalClusterRoleTemplateRESTFunc   NewRESTFunc
	ManagementGlobalSpaceConstraintStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalGlobalSpaceConstraint,
		func() runtime.Object { return &GlobalSpaceConstraint{} },     // Register versioned resource
		func() runtime.Object { return &GlobalSpaceConstraintList{} }, // Register versioned resource list
		NewGlobalSpaceConstraintREST,
	)
	NewGlobalSpaceConstraintREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewGlobalSpaceConstraintRESTFunc(Factory)
	}
	NewGlobalSpaceConstraintRESTFunc NewRESTFunc
	ManagementKioskStorage           = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalKiosk,
		func() runtime.Object { return &Kiosk{} },     // Register versioned resource
		func() runtime.Object { return &KioskList{} }, // Register versioned resource list
		NewKioskREST,
	)
	NewKioskREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewKioskRESTFunc(Factory)
	}
	NewKioskRESTFunc         NewRESTFunc
	ManagementLicenseStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLicense,
		func() runtime.Object { return &License{} },     // Register versioned resource
		func() runtime.Object { return &LicenseList{} }, // Register versioned resource list
		NewLicenseREST,
	)
	NewLicenseREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseRESTFunc(Factory)
	}
	NewLicenseRESTFunc            NewRESTFunc
	ManagementLicenseTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLicenseToken,
		func() runtime.Object { return &LicenseToken{} },     // Register versioned resource
		func() runtime.Object { return &LicenseTokenList{} }, // Register versioned resource list
		NewLicenseTokenREST,
	)
	NewLicenseTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseTokenRESTFunc(Factory)
	}
	NewLicenseTokenRESTFunc      NewRESTFunc
	ManagementLoftUpgradeStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLoftUpgrade,
		func() runtime.Object { return &LoftUpgrade{} },     // Register versioned resource
		func() runtime.Object { return &LoftUpgradeList{} }, // Register versioned resource list
		NewLoftUpgradeREST,
	)
	NewLoftUpgradeREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLoftUpgradeRESTFunc(Factory)
	}
	NewLoftUpgradeRESTFunc          NewRESTFunc
	ManagementOwnedAccessKeyStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalOwnedAccessKey,
		func() runtime.Object { return &OwnedAccessKey{} },     // Register versioned resource
		func() runtime.Object { return &OwnedAccessKeyList{} }, // Register versioned resource list
		NewOwnedAccessKeyREST,
	)
	NewOwnedAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewOwnedAccessKeyRESTFunc(Factory)
	}
	NewOwnedAccessKeyRESTFunc        NewRESTFunc
	ManagementPolicyViolationStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalPolicyViolation,
		func() runtime.Object { return &PolicyViolation{} },     // Register versioned resource
		func() runtime.Object { return &PolicyViolationList{} }, // Register versioned resource list
		NewPolicyViolationREST,
	)
	NewPolicyViolationREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewPolicyViolationRESTFunc(Factory)
	}
	NewPolicyViolationRESTFunc      NewRESTFunc
	ManagementResetAccessKeyStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalResetAccessKey,
		func() runtime.Object { return &ResetAccessKey{} },     // Register versioned resource
		func() runtime.Object { return &ResetAccessKeyList{} }, // Register versioned resource list
		NewResetAccessKeyREST,
	)
	NewResetAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewResetAccessKeyRESTFunc(Factory)
	}
	NewResetAccessKeyRESTFunc NewRESTFunc
	ManagementSelfStorage     = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSelf,
		func() runtime.Object { return &Self{} },     // Register versioned resource
		func() runtime.Object { return &SelfList{} }, // Register versioned resource list
		NewSelfREST,
	)
	NewSelfREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSelfRESTFunc(Factory)
	}
	NewSelfRESTFunc                          NewRESTFunc
	ManagementSelfSubjectAccessReviewStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSelfSubjectAccessReview,
		func() runtime.Object { return &SelfSubjectAccessReview{} },     // Register versioned resource
		func() runtime.Object { return &SelfSubjectAccessReviewList{} }, // Register versioned resource list
		NewSelfSubjectAccessReviewREST,
	)
	NewSelfSubjectAccessReviewREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSelfSubjectAccessReviewRESTFunc(Factory)
	}
	NewSelfSubjectAccessReviewRESTFunc NewRESTFunc
	ManagementSharedSecretStorage      = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSharedSecret,
		func() runtime.Object { return &SharedSecret{} },     // Register versioned resource
		func() runtime.Object { return &SharedSecretList{} }, // Register versioned resource list
		NewSharedSecretREST,
	)
	NewSharedSecretREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSharedSecretRESTFunc(Factory)
	}
	NewSharedSecretRESTFunc        NewRESTFunc
	ManagementSpaceTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSpaceTemplate,
		func() runtime.Object { return &SpaceTemplate{} },     // Register versioned resource
		func() runtime.Object { return &SpaceTemplateList{} }, // Register versioned resource list
		NewSpaceTemplateREST,
	)
	NewSpaceTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSpaceTemplateRESTFunc(Factory)
	}
	NewSpaceTemplateRESTFunc             NewRESTFunc
	ManagementSubjectAccessReviewStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSubjectAccessReview,
		func() runtime.Object { return &SubjectAccessReview{} },     // Register versioned resource
		func() runtime.Object { return &SubjectAccessReviewList{} }, // Register versioned resource list
		NewSubjectAccessReviewREST,
	)
	NewSubjectAccessReviewREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSubjectAccessReviewRESTFunc(Factory)
	}
	NewSubjectAccessReviewRESTFunc NewRESTFunc
	ManagementTaskStorage          = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalTask,
		func() runtime.Object { return &Task{} },     // Register versioned resource
		func() runtime.Object { return &TaskList{} }, // Register versioned resource list
		NewTaskREST,
	)
	NewTaskREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTaskRESTFunc(Factory)
	}
	NewTaskRESTFunc       NewRESTFunc
	ManagementTeamStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalTeam,
		func() runtime.Object { return &Team{} },     // Register versioned resource
		func() runtime.Object { return &TeamList{} }, // Register versioned resource list
		NewTeamREST,
	)
	NewTeamREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamRESTFunc(Factory)
	}
	NewTeamRESTFunc       NewRESTFunc
	ManagementUserStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalUser,
		func() runtime.Object { return &User{} },     // Register versioned resource
		func() runtime.Object { return &UserList{} }, // Register versioned resource list
		NewUserREST,
	)
	NewUserREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserRESTFunc(Factory)
	}
	NewUserRESTFunc                         NewRESTFunc
	ManagementVirtualClusterTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalVirtualClusterTemplate,
		func() runtime.Object { return &VirtualClusterTemplate{} },     // Register versioned resource
		func() runtime.Object { return &VirtualClusterTemplateList{} }, // Register versioned resource list
		NewVirtualClusterTemplateREST,
	)
	NewVirtualClusterTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterTemplateRESTFunc(Factory)
	}
	NewVirtualClusterTemplateRESTFunc NewRESTFunc
	InternalAnnouncement              = builders.NewInternalResource(
		"announcements",
		"Announcement",
		func() runtime.Object { return &Announcement{} },
		func() runtime.Object { return &AnnouncementList{} },
	)
	InternalAnnouncementStatus = builders.NewInternalResourceStatus(
		"announcements",
		"AnnouncementStatus",
		func() runtime.Object { return &Announcement{} },
		func() runtime.Object { return &AnnouncementList{} },
	)
	InternalApp = builders.NewInternalResource(
		"apps",
		"App",
		func() runtime.Object { return &App{} },
		func() runtime.Object { return &AppList{} },
	)
	InternalAppStatus = builders.NewInternalResourceStatus(
		"apps",
		"AppStatus",
		func() runtime.Object { return &App{} },
		func() runtime.Object { return &AppList{} },
	)
	InternalCluster = builders.NewInternalResource(
		"clusters",
		"Cluster",
		func() runtime.Object { return &Cluster{} },
		func() runtime.Object { return &ClusterList{} },
	)
	InternalClusterStatus = builders.NewInternalResourceStatus(
		"clusters",
		"ClusterStatus",
		func() runtime.Object { return &Cluster{} },
		func() runtime.Object { return &ClusterList{} },
	)
	InternalClusterAccessREST = builders.NewInternalSubresource(
		"clusters", "ClusterAccess", "access",
		func() runtime.Object { return &ClusterAccess{} },
	)
	NewClusterAccessREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterAccessRESTFunc(Factory)
	}
	NewClusterAccessRESTFunc  NewRESTFunc
	InternalClusterChartsREST = builders.NewInternalSubresource(
		"clusters", "ClusterCharts", "charts",
		func() runtime.Object { return &ClusterCharts{} },
	)
	NewClusterChartsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterChartsRESTFunc(Factory)
	}
	NewClusterChartsRESTFunc  NewRESTFunc
	InternalClusterDomainREST = builders.NewInternalSubresource(
		"clusters", "ClusterDomain", "domain",
		func() runtime.Object { return &ClusterDomain{} },
	)
	NewClusterDomainREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterDomainRESTFunc(Factory)
	}
	NewClusterDomainRESTFunc   NewRESTFunc
	InternalClusterMembersREST = builders.NewInternalSubresource(
		"clusters", "ClusterMembers", "members",
		func() runtime.Object { return &ClusterMembers{} },
	)
	NewClusterMembersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterMembersRESTFunc(Factory)
	}
	NewClusterMembersRESTFunc NewRESTFunc
	InternalClusterResetREST  = builders.NewInternalSubresource(
		"clusters", "ClusterReset", "reset",
		func() runtime.Object { return &ClusterReset{} },
	)
	NewClusterResetREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterResetRESTFunc(Factory)
	}
	NewClusterResetRESTFunc                   NewRESTFunc
	InternalClusterVirtualClusterDefaultsREST = builders.NewInternalSubresource(
		"clusters", "ClusterVirtualClusterDefaults", "virtualclusterdefaults",
		func() runtime.Object { return &ClusterVirtualClusterDefaults{} },
	)
	NewClusterVirtualClusterDefaultsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterVirtualClusterDefaultsRESTFunc(Factory)
	}
	NewClusterVirtualClusterDefaultsRESTFunc NewRESTFunc
	InternalClusterAccountTemplate           = builders.NewInternalResource(
		"clusteraccounttemplates",
		"ClusterAccountTemplate",
		func() runtime.Object { return &ClusterAccountTemplate{} },
		func() runtime.Object { return &ClusterAccountTemplateList{} },
	)
	InternalClusterAccountTemplateStatus = builders.NewInternalResourceStatus(
		"clusteraccounttemplates",
		"ClusterAccountTemplateStatus",
		func() runtime.Object { return &ClusterAccountTemplate{} },
		func() runtime.Object { return &ClusterAccountTemplateList{} },
	)
	InternalClusterConnect = builders.NewInternalResource(
		"clusterconnect",
		"ClusterConnect",
		func() runtime.Object { return &ClusterConnect{} },
		func() runtime.Object { return &ClusterConnectList{} },
	)
	InternalClusterConnectStatus = builders.NewInternalResourceStatus(
		"clusterconnect",
		"ClusterConnectStatus",
		func() runtime.Object { return &ClusterConnect{} },
		func() runtime.Object { return &ClusterConnectList{} },
	)
	InternalConfig = builders.NewInternalResource(
		"configs",
		"Config",
		func() runtime.Object { return &Config{} },
		func() runtime.Object { return &ConfigList{} },
	)
	InternalConfigStatus = builders.NewInternalResourceStatus(
		"configs",
		"ConfigStatus",
		func() runtime.Object { return &Config{} },
		func() runtime.Object { return &ConfigList{} },
	)
	InternalDirectClusterEndpointToken = builders.NewInternalResource(
		"directclusterendpointtokens",
		"DirectClusterEndpointToken",
		func() runtime.Object { return &DirectClusterEndpointToken{} },
		func() runtime.Object { return &DirectClusterEndpointTokenList{} },
	)
	InternalDirectClusterEndpointTokenStatus = builders.NewInternalResourceStatus(
		"directclusterendpointtokens",
		"DirectClusterEndpointTokenStatus",
		func() runtime.Object { return &DirectClusterEndpointToken{} },
		func() runtime.Object { return &DirectClusterEndpointTokenList{} },
	)
	InternalEvent = builders.NewInternalResource(
		"events",
		"Event",
		func() runtime.Object { return &Event{} },
		func() runtime.Object { return &EventList{} },
	)
	InternalEventStatus = builders.NewInternalResourceStatus(
		"events",
		"EventStatus",
		func() runtime.Object { return &Event{} },
		func() runtime.Object { return &EventList{} },
	)
	InternalFeature = builders.NewInternalResource(
		"features",
		"Feature",
		func() runtime.Object { return &Feature{} },
		func() runtime.Object { return &FeatureList{} },
	)
	InternalFeatureStatus = builders.NewInternalResourceStatus(
		"features",
		"FeatureStatus",
		func() runtime.Object { return &Feature{} },
		func() runtime.Object { return &FeatureList{} },
	)
	InternalGlobalClusterAccess = builders.NewInternalResource(
		"globalclusteraccesses",
		"GlobalClusterAccess",
		func() runtime.Object { return &GlobalClusterAccess{} },
		func() runtime.Object { return &GlobalClusterAccessList{} },
	)
	InternalGlobalClusterAccessStatus = builders.NewInternalResourceStatus(
		"globalclusteraccesses",
		"GlobalClusterAccessStatus",
		func() runtime.Object { return &GlobalClusterAccess{} },
		func() runtime.Object { return &GlobalClusterAccessList{} },
	)
	InternalGlobalClusterRoleTemplate = builders.NewInternalResource(
		"globalclusterroletemplates",
		"GlobalClusterRoleTemplate",
		func() runtime.Object { return &GlobalClusterRoleTemplate{} },
		func() runtime.Object { return &GlobalClusterRoleTemplateList{} },
	)
	InternalGlobalClusterRoleTemplateStatus = builders.NewInternalResourceStatus(
		"globalclusterroletemplates",
		"GlobalClusterRoleTemplateStatus",
		func() runtime.Object { return &GlobalClusterRoleTemplate{} },
		func() runtime.Object { return &GlobalClusterRoleTemplateList{} },
	)
	InternalGlobalSpaceConstraint = builders.NewInternalResource(
		"globalspaceconstraints",
		"GlobalSpaceConstraint",
		func() runtime.Object { return &GlobalSpaceConstraint{} },
		func() runtime.Object { return &GlobalSpaceConstraintList{} },
	)
	InternalGlobalSpaceConstraintStatus = builders.NewInternalResourceStatus(
		"globalspaceconstraints",
		"GlobalSpaceConstraintStatus",
		func() runtime.Object { return &GlobalSpaceConstraint{} },
		func() runtime.Object { return &GlobalSpaceConstraintList{} },
	)
	InternalKiosk = builders.NewInternalResource(
		"kiosk",
		"Kiosk",
		func() runtime.Object { return &Kiosk{} },
		func() runtime.Object { return &KioskList{} },
	)
	InternalKioskStatus = builders.NewInternalResourceStatus(
		"kiosk",
		"KioskStatus",
		func() runtime.Object { return &Kiosk{} },
		func() runtime.Object { return &KioskList{} },
	)
	InternalLicense = builders.NewInternalResource(
		"licenses",
		"License",
		func() runtime.Object { return &License{} },
		func() runtime.Object { return &LicenseList{} },
	)
	InternalLicenseStatus = builders.NewInternalResourceStatus(
		"licenses",
		"LicenseStatus",
		func() runtime.Object { return &License{} },
		func() runtime.Object { return &LicenseList{} },
	)
	InternalLicenseToken = builders.NewInternalResource(
		"licensetokens",
		"LicenseToken",
		func() runtime.Object { return &LicenseToken{} },
		func() runtime.Object { return &LicenseTokenList{} },
	)
	InternalLicenseTokenStatus = builders.NewInternalResourceStatus(
		"licensetokens",
		"LicenseTokenStatus",
		func() runtime.Object { return &LicenseToken{} },
		func() runtime.Object { return &LicenseTokenList{} },
	)
	InternalLoftUpgrade = builders.NewInternalResource(
		"loftupgrades",
		"LoftUpgrade",
		func() runtime.Object { return &LoftUpgrade{} },
		func() runtime.Object { return &LoftUpgradeList{} },
	)
	InternalLoftUpgradeStatus = builders.NewInternalResourceStatus(
		"loftupgrades",
		"LoftUpgradeStatus",
		func() runtime.Object { return &LoftUpgrade{} },
		func() runtime.Object { return &LoftUpgradeList{} },
	)
	InternalOwnedAccessKey = builders.NewInternalResource(
		"ownedaccesskeys",
		"OwnedAccessKey",
		func() runtime.Object { return &OwnedAccessKey{} },
		func() runtime.Object { return &OwnedAccessKeyList{} },
	)
	InternalOwnedAccessKeyStatus = builders.NewInternalResourceStatus(
		"ownedaccesskeys",
		"OwnedAccessKeyStatus",
		func() runtime.Object { return &OwnedAccessKey{} },
		func() runtime.Object { return &OwnedAccessKeyList{} },
	)
	InternalPolicyViolation = builders.NewInternalResource(
		"policyviolations",
		"PolicyViolation",
		func() runtime.Object { return &PolicyViolation{} },
		func() runtime.Object { return &PolicyViolationList{} },
	)
	InternalPolicyViolationStatus = builders.NewInternalResourceStatus(
		"policyviolations",
		"PolicyViolationStatus",
		func() runtime.Object { return &PolicyViolation{} },
		func() runtime.Object { return &PolicyViolationList{} },
	)
	InternalResetAccessKey = builders.NewInternalResource(
		"resetaccesskeys",
		"ResetAccessKey",
		func() runtime.Object { return &ResetAccessKey{} },
		func() runtime.Object { return &ResetAccessKeyList{} },
	)
	InternalResetAccessKeyStatus = builders.NewInternalResourceStatus(
		"resetaccesskeys",
		"ResetAccessKeyStatus",
		func() runtime.Object { return &ResetAccessKey{} },
		func() runtime.Object { return &ResetAccessKeyList{} },
	)
	InternalSelf = builders.NewInternalResource(
		"selves",
		"Self",
		func() runtime.Object { return &Self{} },
		func() runtime.Object { return &SelfList{} },
	)
	InternalSelfStatus = builders.NewInternalResourceStatus(
		"selves",
		"SelfStatus",
		func() runtime.Object { return &Self{} },
		func() runtime.Object { return &SelfList{} },
	)
	InternalSelfSubjectAccessReview = builders.NewInternalResource(
		"selfsubjectaccessreviews",
		"SelfSubjectAccessReview",
		func() runtime.Object { return &SelfSubjectAccessReview{} },
		func() runtime.Object { return &SelfSubjectAccessReviewList{} },
	)
	InternalSelfSubjectAccessReviewStatus = builders.NewInternalResourceStatus(
		"selfsubjectaccessreviews",
		"SelfSubjectAccessReviewStatus",
		func() runtime.Object { return &SelfSubjectAccessReview{} },
		func() runtime.Object { return &SelfSubjectAccessReviewList{} },
	)
	InternalSharedSecret = builders.NewInternalResource(
		"sharedsecrets",
		"SharedSecret",
		func() runtime.Object { return &SharedSecret{} },
		func() runtime.Object { return &SharedSecretList{} },
	)
	InternalSharedSecretStatus = builders.NewInternalResourceStatus(
		"sharedsecrets",
		"SharedSecretStatus",
		func() runtime.Object { return &SharedSecret{} },
		func() runtime.Object { return &SharedSecretList{} },
	)
	InternalSpaceTemplate = builders.NewInternalResource(
		"spacetemplates",
		"SpaceTemplate",
		func() runtime.Object { return &SpaceTemplate{} },
		func() runtime.Object { return &SpaceTemplateList{} },
	)
	InternalSpaceTemplateStatus = builders.NewInternalResourceStatus(
		"spacetemplates",
		"SpaceTemplateStatus",
		func() runtime.Object { return &SpaceTemplate{} },
		func() runtime.Object { return &SpaceTemplateList{} },
	)
	InternalSubjectAccessReview = builders.NewInternalResource(
		"subjectaccessreviews",
		"SubjectAccessReview",
		func() runtime.Object { return &SubjectAccessReview{} },
		func() runtime.Object { return &SubjectAccessReviewList{} },
	)
	InternalSubjectAccessReviewStatus = builders.NewInternalResourceStatus(
		"subjectaccessreviews",
		"SubjectAccessReviewStatus",
		func() runtime.Object { return &SubjectAccessReview{} },
		func() runtime.Object { return &SubjectAccessReviewList{} },
	)
	InternalTask = builders.NewInternalResource(
		"tasks",
		"Task",
		func() runtime.Object { return &Task{} },
		func() runtime.Object { return &TaskList{} },
	)
	InternalTaskStatus = builders.NewInternalResourceStatus(
		"tasks",
		"TaskStatus",
		func() runtime.Object { return &Task{} },
		func() runtime.Object { return &TaskList{} },
	)
	InternalTaskLogREST = builders.NewInternalSubresource(
		"tasks", "TaskLog", "log",
		func() runtime.Object { return &TaskLog{} },
	)
	NewTaskLogREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTaskLogRESTFunc(Factory)
	}
	NewTaskLogRESTFunc NewRESTFunc
	InternalTeam       = builders.NewInternalResource(
		"teams",
		"Team",
		func() runtime.Object { return &Team{} },
		func() runtime.Object { return &TeamList{} },
	)
	InternalTeamStatus = builders.NewInternalResourceStatus(
		"teams",
		"TeamStatus",
		func() runtime.Object { return &Team{} },
		func() runtime.Object { return &TeamList{} },
	)
	InternalTeamAccessKeysREST = builders.NewInternalSubresource(
		"teams", "TeamAccessKeys", "accesskeys",
		func() runtime.Object { return &TeamAccessKeys{} },
	)
	NewTeamAccessKeysREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamAccessKeysRESTFunc(Factory)
	}
	NewTeamAccessKeysRESTFunc NewRESTFunc
	InternalTeamClustersREST  = builders.NewInternalSubresource(
		"teams", "TeamClusters", "clusters",
		func() runtime.Object { return &TeamClusters{} },
	)
	NewTeamClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamClustersRESTFunc(Factory)
	}
	NewTeamClustersRESTFunc NewRESTFunc
	InternalUser            = builders.NewInternalResource(
		"users",
		"User",
		func() runtime.Object { return &User{} },
		func() runtime.Object { return &UserList{} },
	)
	InternalUserStatus = builders.NewInternalResourceStatus(
		"users",
		"UserStatus",
		func() runtime.Object { return &User{} },
		func() runtime.Object { return &UserList{} },
	)
	InternalUserAccessKeysREST = builders.NewInternalSubresource(
		"users", "UserAccessKeys", "accesskeys",
		func() runtime.Object { return &UserAccessKeys{} },
	)
	NewUserAccessKeysREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserAccessKeysRESTFunc(Factory)
	}
	NewUserAccessKeysRESTFunc NewRESTFunc
	InternalUserClustersREST  = builders.NewInternalSubresource(
		"users", "UserClusters", "clusters",
		func() runtime.Object { return &UserClusters{} },
	)
	NewUserClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserClustersRESTFunc(Factory)
	}
	NewUserClustersRESTFunc NewRESTFunc
	InternalUserProfileREST = builders.NewInternalSubresource(
		"users", "UserProfile", "profile",
		func() runtime.Object { return &UserProfile{} },
	)
	NewUserProfileREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserProfileRESTFunc(Factory)
	}
	NewUserProfileRESTFunc         NewRESTFunc
	InternalVirtualClusterTemplate = builders.NewInternalResource(
		"virtualclustertemplates",
		"VirtualClusterTemplate",
		func() runtime.Object { return &VirtualClusterTemplate{} },
		func() runtime.Object { return &VirtualClusterTemplateList{} },
	)
	InternalVirtualClusterTemplateStatus = builders.NewInternalResourceStatus(
		"virtualclustertemplates",
		"VirtualClusterTemplateStatus",
		func() runtime.Object { return &VirtualClusterTemplate{} },
		func() runtime.Object { return &VirtualClusterTemplateList{} },
	)
	// Registered resources and subresources
	ApiVersion = builders.NewApiGroup("management.loft.sh").WithKinds(
		InternalAnnouncement,
		InternalAnnouncementStatus,
		InternalApp,
		InternalAppStatus,
		InternalCluster,
		InternalClusterStatus,
		InternalClusterAccessREST,
		InternalClusterChartsREST,
		InternalClusterDomainREST,
		InternalClusterMembersREST,
		InternalClusterResetREST,
		InternalClusterVirtualClusterDefaultsREST,
		InternalClusterAccountTemplate,
		InternalClusterAccountTemplateStatus,
		InternalClusterConnect,
		InternalClusterConnectStatus,
		InternalConfig,
		InternalConfigStatus,
		InternalDirectClusterEndpointToken,
		InternalDirectClusterEndpointTokenStatus,
		InternalEvent,
		InternalEventStatus,
		InternalFeature,
		InternalFeatureStatus,
		InternalGlobalClusterAccess,
		InternalGlobalClusterAccessStatus,
		InternalGlobalClusterRoleTemplate,
		InternalGlobalClusterRoleTemplateStatus,
		InternalGlobalSpaceConstraint,
		InternalGlobalSpaceConstraintStatus,
		InternalKiosk,
		InternalKioskStatus,
		InternalLicense,
		InternalLicenseStatus,
		InternalLicenseToken,
		InternalLicenseTokenStatus,
		InternalLoftUpgrade,
		InternalLoftUpgradeStatus,
		InternalOwnedAccessKey,
		InternalOwnedAccessKeyStatus,
		InternalPolicyViolation,
		InternalPolicyViolationStatus,
		InternalResetAccessKey,
		InternalResetAccessKeyStatus,
		InternalSelf,
		InternalSelfStatus,
		InternalSelfSubjectAccessReview,
		InternalSelfSubjectAccessReviewStatus,
		InternalSharedSecret,
		InternalSharedSecretStatus,
		InternalSpaceTemplate,
		InternalSpaceTemplateStatus,
		InternalSubjectAccessReview,
		InternalSubjectAccessReviewStatus,
		InternalTask,
		InternalTaskStatus,
		InternalTaskLogREST,
		InternalTeam,
		InternalTeamStatus,
		InternalTeamAccessKeysREST,
		InternalTeamClustersREST,
		InternalUser,
		InternalUserStatus,
		InternalUserAccessKeysREST,
		InternalUserClustersREST,
		InternalUserProfileREST,
		InternalVirtualClusterTemplate,
		InternalVirtualClusterTemplateStatus,
	)

	// Required by code generated by go2idl
	AddToScheme = (&runtime.SchemeBuilder{
		ApiVersion.SchemeBuilder.AddToScheme,
		RegisterDefaults,
	}).AddToScheme
	SchemeBuilder      = ApiVersion.SchemeBuilder
	localSchemeBuilder = &SchemeBuilder
	SchemeGroupVersion = ApiVersion.GroupVersion
)

// Required by code generated by go2idl
// Kind takes an unqualified kind and returns a Group qualified GroupKind
func Kind(kind string) schema.GroupKind {
	return SchemeGroupVersion.WithKind(kind).GroupKind()
}

// Required by code generated by go2idl
// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource {
	return SchemeGroupVersion.WithResource(resource).GroupResource()
}

type AccessKeyType string
type Level string
type RequestTarget string
type Stage string

type Analytics struct {
	Endpoint      string
	BatchEndpoint string
	Requests      []ResoureRequests
	Token         string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Announcement struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   AnnouncementSpec
	Status AnnouncementStatus
}

type AnnouncementSpec struct {
}

type AnnouncementStatus struct {
	Announcement   string
	AnalyticsToken string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type App struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   AppSpec
	Status AppStatus
}

type AppSpec struct {
	storagev1.AppSpec
}

type AppStatus struct {
	storagev1.AppStatus
}

type Apps struct {
	NoDefault      bool
	Repositories   []storagev1.HelmChartRepository
	PredefinedApps []PredefinedApp
}

type Audit struct {
	Enabled           bool
	Level             int
	Policy            AuditPolicy
	DataStoreEndpoint string
	DataStoreMaxAge   *int
	Path              string
	MaxAge            int
	MaxBackups        int
	MaxSize           int
	Compress          bool
}

type AuditPolicy struct {
	Rules      []AuditPolicyRule
	OmitStages []auditv1.Stage
}

type AuditPolicyRule struct {
	Level           auditv1.Level
	Users           []string
	UserGroups      []string
	Verbs           []string
	Resources       []GroupResources
	Namespaces      []string
	NonResourceURLs []string
	OmitStages      []auditv1.Stage
	RequestTargets  []auditv1.RequestTarget
	Clusters        []string
}

type Authentication struct {
	Password  *AuthenticationPassword
	OIDC      *AuthenticationOIDC
	Github    *AuthenticationGithub
	Gitlab    *AuthenticationGitlab
	Google    *AuthenticationGoogle
	Microsoft *AuthenticationMicrosoft
}

type AuthenticationClusterAccountTemplates struct {
	ClusterAccountTemplates      []storagev1.UserClusterAccountTemplate
	GroupClusterAccountTemplates []AuthenticationGroupClusterAccountTemplate
}

type AuthenticationGithub struct {
	AuthenticationClusterAccountTemplates
	ClientID     string
	ClientSecret string
	RedirectURI  string
	Orgs         []AuthenticationGithubOrg
	HostName     string
	RootCA       string
}

type AuthenticationGithubOrg struct {
	Name  string
	Teams []string
}

type AuthenticationGitlab struct {
	AuthenticationClusterAccountTemplates
	ClientID     string
	ClientSecret string
	RedirectURI  string
	BaseURL      string
	Groups       []string
}

type AuthenticationGoogle struct {
	AuthenticationClusterAccountTemplates
	ClientID               string
	ClientSecret           string
	RedirectURI            string
	Scopes                 []string
	HostedDomains          []string
	Groups                 []string
	ServiceAccountFilePath string
	AdminEmail             string
}

type AuthenticationGroupClusterAccountTemplate struct {
	Group                   string
	ClusterAccountTemplates []storagev1.UserClusterAccountTemplate
}

type AuthenticationMicrosoft struct {
	AuthenticationClusterAccountTemplates
	ClientID             string
	ClientSecret         string
	RedirectURI          string
	Tenant               string
	Groups               []string
	OnlySecurityGroups   bool
	UseGroupsAsWhitelist bool
}

type AuthenticationOIDC struct {
	AuthenticationClusterAccountTemplates
	IssuerURL      string
	ClientID       string
	ClientSecret   string
	RedirectURI    string
	CAFile         string
	InsecureCA     bool
	UsernameClaim  string
	UsernamePrefix string
	GroupsClaim    string
	Groups         []string
	GetUserInfo    bool
	GroupsPrefix   string
	Type           string
}

type AuthenticationPassword struct {
	Disabled bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Cluster struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterSpec
	Status ClusterStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccess struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Teams []ClusterMember
	Users []ClusterMember
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccountTemplate struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterAccountTemplateSpec
	Status ClusterAccountTemplateStatus
}

type ClusterAccountTemplateSpec struct {
	storagev1.ClusterAccountTemplateSpec
}

type ClusterAccountTemplateStatus struct {
	storagev1.ClusterAccountTemplateStatus
}

type ClusterAccounts struct {
	Accounts []string
	Cluster  storagev1.Cluster
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterCharts struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Charts []storagev1.HelmChart
	Busy   bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterConnect struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterConnectSpec
	Status ClusterConnectStatus
}

type ClusterConnectSpec struct {
	Config          string
	AdminUser       string
	ClusterTemplate Cluster
}

type ClusterConnectStatus struct {
	Failed  bool
	Reason  string
	Message string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterDomain struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Target string
	Domain string
}

type ClusterMember struct {
	Info clusterv1.EntityInfo
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMembers struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Teams []ClusterMember
	Users []ClusterMember
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterReset struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Agent bool
	RBAC  bool
}

type ClusterSpec struct {
	storagev1.ClusterSpec
}

type ClusterStatus struct {
	storagev1.ClusterStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterVirtualClusterDefaults struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	DefaultTemplate *storagev1.VirtualClusterTemplate
	LatestVersion   string
	Values          string
	Warning         string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Config struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ConfigSpec
	Status ConfigStatus
}

type ConfigSpec struct {
	Raw []byte
}

type ConfigStatus struct {
	Authentication Authentication
	OIDC           *OIDC
	Apps           *Apps
	Audit          *Audit
}

type CustomerInfo struct {
	Company      string
	Email        string
	FirstName    string
	LastName     string
	AddressLine1 string
	AddressLine2 string
	City         string
	PostalCode   string
	Country      string
	Created      int64
}

type DefaultPaymentMethod struct {
	Card *DefaultPaymentMethodCard
}

type DefaultPaymentMethodCard struct {
	Last4    string
	ExpMonth uint64
	ExpYear  uint64
	Brand    string
	Funding  string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DirectClusterEndpointToken struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   DirectClusterEndpointTokenSpec
	Status DirectClusterEndpointTokenStatus
}

type DirectClusterEndpointTokenSpec struct {
}

type DirectClusterEndpointTokenStatus struct {
	Token string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Event struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   EventSpec
	Status EventStatus
}

type EventSpec struct {
}

type EventStatus struct {
	auditv1.Event
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Feature struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   FeatureSpec
	Status FeatureStatus
}

type FeatureSpec struct {
}

type FeatureStatus struct {
	Enabled bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type GlobalClusterAccess struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   GlobalClusterAccessSpec
	Status GlobalClusterAccessStatus
}

type GlobalClusterAccessSpec struct {
	storagev1.GlobalClusterAccessSpec
}

type GlobalClusterAccessStatus struct {
	storagev1.GlobalClusterAccessStatus
	Clusters        []*clusterv1.EntityInfo
	Users           []*clusterv1.UserOrTeam
	Teams           []*clusterv1.EntityInfo
	SpaceConstraint *clusterv1.EntityInfo
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type GlobalClusterRoleTemplate struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   GlobalClusterRoleTemplateSpec
	Status GlobalClusterRoleTemplateStatus
}

type GlobalClusterRoleTemplateSpec struct {
	storagev1.GlobalClusterRoleTemplateSpec
}

type GlobalClusterRoleTemplateStatus struct {
	storagev1.GlobalClusterRoleTemplateStatus
	Clusters []*clusterv1.EntityInfo
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type GlobalSpaceConstraint struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   GlobalSpaceConstraintSpec
	Status GlobalSpaceConstraintStatus
}

type GlobalSpaceConstraintSpec struct {
	storagev1.GlobalSpaceConstraintSpec
}

type GlobalSpaceConstraintStatus struct {
	storagev1.GlobalSpaceConstraintStatus
	ClusterRole *clusterv1.EntityInfo
	Clusters    []*clusterv1.EntityInfo
}

type GroupResources struct {
	Group         string
	Resources     []string
	ResourceNames []string
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Kiosk struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   KioskSpec
	Status KioskStatus
}

type KioskSpec struct {
	ConfigAccount         configv1alpha1.Account
	Template              configv1alpha1.Template
	TemplateInstance      configv1alpha1.TemplateInstance
	JsPolicy              policyv1beta1.JsPolicy
	JsPolicyBundle        policyv1beta1.JsPolicyBundle
	JsPolicyViolations    policyv1beta1.JsPolicyViolations
	HelmRelease           clusterv1.HelmRelease
	SleepModeConfig       clusterv1.SleepModeConfig
	Space                 clusterv1.Space
	VirtualCluster        clusterv1.VirtualCluster
	ClusterAccess         clusterv1.ClusterAccess
	ClusterQuota          clusterv1.ClusterQuota
	SpaceConstraint       agentstoragev1.SpaceConstraint
	StorageClusterAccess  agentstoragev1.ClusterAccess
	ClusterRoleTemplate   agentstoragev1.ClusterRoleTemplate
	StorageClusterQuota   agentstoragev1.ClusterQuota
	StorageVirtualCluster agentstoragev1.VirtualCluster
	ClusterUser           agentstoragev1.ClusterUser
	ClusterTeam           agentstoragev1.ClusterTeam
}

type KioskStatus struct {
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type License struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LicenseSpec
	Status LicenseStatus
}

type LicenseInfo struct {
	Announcement   string
	License        string
	CurrentTime    int64
	ResourceLimits []ResourceLimit
	BlockRequests  []ResoureRequests
	Features       map[string]bool
	Customer       CustomerInfo
	Subscription   SubscriptionInfo
	Quantity       int64
	Plan           Plan
	Promotions     Promotions
	Analytics      Analytics
	Links          map[string]string
	BaseDomains    []string
}

type LicenseSpec struct {
}

type LicenseStatus struct {
	Instance string
	Info     LicenseInfo
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseToken struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LicenseTokenSpec
	Status LicenseTokenStatus
}

type LicenseTokenSpec struct {
}

type LicenseTokenStatus struct {
	Token string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LoftUpgrade struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LoftUpgradeSpec
	Status LoftUpgradeStatus
}

type LoftUpgradeSpec struct {
	Namespace string
	Release   string
	Version   string
}

type LoftUpgradeStatus struct {
}

type OIDC struct {
	Enabled bool
	Clients []OIDCClient
}

type OIDCClient struct {
	Name         string
	ClientID     string
	ClientSecret string
	RedirectURIs []string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type OwnedAccessKey struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   OwnedAccessKeySpec
	Status OwnedAccessKeyStatus
}

type OwnedAccessKeySpec struct {
	storagev1.AccessKeySpec
}

type OwnedAccessKeyStatus struct {
	storagev1.AccessKeyStatus
}

type Plan struct {
	Price    int64
	Currency string
	Interval string
	Product  PlanProduct
}

type PlanProduct struct {
	Name      string
	UnitLabel string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type PolicyViolation struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   PolicyViolationSpec
	Status PolicyViolationStatus
}

type PolicyViolationSpec struct {
}

type PolicyViolationStatus struct {
	Policy    string
	Cluster   string
	User      *clusterv1.EntityInfo
	Violation policyv1beta1.PolicyViolation
}

type PredefinedApp struct {
	Chart          string
	InitialVersion string
	InitialValues  string
	Clusters       []string
	Title          string
	IconURL        string
	ReadmeURL      string
}

type Promotions struct {
	Trial *TrialPromotion
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ResetAccessKey struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ResetAccessKeySpec
	Status ResetAccessKeyStatus
}

type ResetAccessKeySpec struct {
	storagev1.AccessKeySpec
}

type ResetAccessKeyStatus struct {
	storagev1.AccessKeyStatus
}

type ResourceLimit struct {
	Group             string
	Version           string
	Kind              string
	Limit             int64
	AcrossAllClusters bool
	BlockRequests     []ResoureRequests
}

type ResoureRequests struct {
	Verbs      []string
	Group      string
	Resource   string
	Management bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Self struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SelfSpec
	Status SelfStatus
}

type SelfSpec struct {
}

type SelfStatus struct {
	User          *UserInfo
	Team          *clusterv1.EntityInfo
	AccessKey     string
	AccessKeyType storagev1.AccessKeyType
	Subject       string
	Groups        []string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfSubjectAccessReview struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SelfSubjectAccessReviewSpec
	Status SelfSubjectAccessReviewStatus
}

type SelfSubjectAccessReviewSpec struct {
	authorizationv1.SelfSubjectAccessReviewSpec
}

type SelfSubjectAccessReviewStatus struct {
	authorizationv1.SubjectAccessReviewStatus
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SharedSecret struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SharedSecretSpec
	Status SharedSecretStatus
}

type SharedSecretSpec struct {
	storagev1.SharedSecretSpec
}

type SharedSecretStatus struct {
	storagev1.SharedSecretStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceTemplate struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SpaceTemplateSpec
	Status SpaceTemplateStatus
}

type SpaceTemplateSpec struct {
	storagev1.SpaceTemplateSpec
}

type SpaceTemplateStatus struct {
	storagev1.SpaceTemplateStatus
	Apps []*clusterv1.EntityInfo
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SubjectAccessReview struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SubjectAccessReviewSpec
	Status SubjectAccessReviewStatus
}

type SubjectAccessReviewSpec struct {
	authorizationv1.SubjectAccessReviewSpec
}

type SubjectAccessReviewStatus struct {
	authorizationv1.SubjectAccessReviewStatus
}

type SubscriptionInfo struct {
	TrialEnd             int64
	Status               string
	CurrentPeriodEnd     int64
	NextInvoice          int64
	DefaultPaymentMethod *DefaultPaymentMethod
	Created              int64
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Task struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   TaskSpec
	Status TaskStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskLog struct {
	metav1.TypeMeta
	metav1.ObjectMeta
}

type TaskSpec struct {
	storagev1.TaskSpec
}

type TaskStatus struct {
	storagev1.TaskStatus
	Owner   *clusterv1.UserOrTeam
	Cluster *clusterv1.EntityInfo
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Team struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   TeamSpec
	Status TeamStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamAccessKeys struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	AccessKeys []OwnedAccessKey
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClusters struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Clusters []ClusterAccounts
}

type TeamSpec struct {
	storagev1.TeamSpec
}

type TeamStatus struct {
	storagev1.TeamStatus
}

type TrialPromotion struct {
	Product     string
	Description string
	Link        string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type User struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   UserSpec
	Status UserStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserAccessKeys struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	AccessKeys []OwnedAccessKey
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClusters struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Clusters []ClusterAccounts
}

type UserInfo struct {
	clusterv1.EntityInfo
	Teams []*clusterv1.EntityInfo
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserProfile struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	DisplayName string
	Username    string
	Password    string
	Email       string
	Icon        *string
	Custom      string
}

type UserSpec struct {
	storagev1.UserSpec
}

type UserStatus struct {
	storagev1.UserStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterTemplate struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   VirtualClusterTemplateSpec
	Status VirtualClusterTemplateStatus
}

type VirtualClusterTemplateSpec struct {
	storagev1.VirtualClusterTemplateSpec
}

type VirtualClusterTemplateStatus struct {
	storagev1.VirtualClusterTemplateStatus
	Apps []*clusterv1.EntityInfo
}

//
// Announcement Functions and Structs
//
// +k8s:deepcopy-gen=false
type AnnouncementStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AnnouncementStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AnnouncementList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Announcement
}

func (Announcement) NewStatus() interface{} {
	return AnnouncementStatus{}
}

func (pc *Announcement) GetStatus() interface{} {
	return pc.Status
}

func (pc *Announcement) SetStatus(s interface{}) {
	pc.Status = s.(AnnouncementStatus)
}

func (pc *Announcement) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Announcement) SetSpec(s interface{}) {
	pc.Spec = s.(AnnouncementSpec)
}

func (pc *Announcement) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Announcement) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Announcement) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Announcement.
// +k8s:deepcopy-gen=false
type AnnouncementRegistry interface {
	ListAnnouncements(ctx context.Context, options *internalversion.ListOptions) (*AnnouncementList, error)
	GetAnnouncement(ctx context.Context, id string, options *metav1.GetOptions) (*Announcement, error)
	CreateAnnouncement(ctx context.Context, id *Announcement) (*Announcement, error)
	UpdateAnnouncement(ctx context.Context, id *Announcement) (*Announcement, error)
	DeleteAnnouncement(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAnnouncementRegistry(sp builders.StandardStorageProvider) AnnouncementRegistry {
	return &storageAnnouncement{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageAnnouncement struct {
	builders.StandardStorageProvider
}

func (s *storageAnnouncement) ListAnnouncements(ctx context.Context, options *internalversion.ListOptions) (*AnnouncementList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AnnouncementList), err
}

func (s *storageAnnouncement) GetAnnouncement(ctx context.Context, id string, options *metav1.GetOptions) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) CreateAnnouncement(ctx context.Context, object *Announcement) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) UpdateAnnouncement(ctx context.Context, object *Announcement) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) DeleteAnnouncement(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// App Functions and Structs
//
// +k8s:deepcopy-gen=false
type AppStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AppStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AppList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []App
}

func (App) NewStatus() interface{} {
	return AppStatus{}
}

func (pc *App) GetStatus() interface{} {
	return pc.Status
}

func (pc *App) SetStatus(s interface{}) {
	pc.Status = s.(AppStatus)
}

func (pc *App) GetSpec() interface{} {
	return pc.Spec
}

func (pc *App) SetSpec(s interface{}) {
	pc.Spec = s.(AppSpec)
}

func (pc *App) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *App) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc App) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store App.
// +k8s:deepcopy-gen=false
type AppRegistry interface {
	ListApps(ctx context.Context, options *internalversion.ListOptions) (*AppList, error)
	GetApp(ctx context.Context, id string, options *metav1.GetOptions) (*App, error)
	CreateApp(ctx context.Context, id *App) (*App, error)
	UpdateApp(ctx context.Context, id *App) (*App, error)
	DeleteApp(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAppRegistry(sp builders.StandardStorageProvider) AppRegistry {
	return &storageApp{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageApp struct {
	builders.StandardStorageProvider
}

func (s *storageApp) ListApps(ctx context.Context, options *internalversion.ListOptions) (*AppList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AppList), err
}

func (s *storageApp) GetApp(ctx context.Context, id string, options *metav1.GetOptions) (*App, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) CreateApp(ctx context.Context, object *App) (*App, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) UpdateApp(ctx context.Context, object *App) (*App, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) DeleteApp(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Cluster Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Cluster
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccessList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterAccess
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterChartsList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterCharts
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterDomainList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterDomain
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMembersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterMembers
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterResetList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterReset
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterVirtualClusterDefaultsList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterVirtualClusterDefaults
}

func (Cluster) NewStatus() interface{} {
	return ClusterStatus{}
}

func (pc *Cluster) GetStatus() interface{} {
	return pc.Status
}

func (pc *Cluster) SetStatus(s interface{}) {
	pc.Status = s.(ClusterStatus)
}

func (pc *Cluster) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Cluster) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterSpec)
}

func (pc *Cluster) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Cluster) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Cluster) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Cluster.
// +k8s:deepcopy-gen=false
type ClusterRegistry interface {
	ListClusters(ctx context.Context, options *internalversion.ListOptions) (*ClusterList, error)
	GetCluster(ctx context.Context, id string, options *metav1.GetOptions) (*Cluster, error)
	CreateCluster(ctx context.Context, id *Cluster) (*Cluster, error)
	UpdateCluster(ctx context.Context, id *Cluster) (*Cluster, error)
	DeleteCluster(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterRegistry(sp builders.StandardStorageProvider) ClusterRegistry {
	return &storageCluster{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageCluster struct {
	builders.StandardStorageProvider
}

func (s *storageCluster) ListClusters(ctx context.Context, options *internalversion.ListOptions) (*ClusterList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterList), err
}

func (s *storageCluster) GetCluster(ctx context.Context, id string, options *metav1.GetOptions) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) CreateCluster(ctx context.Context, object *Cluster) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) UpdateCluster(ctx context.Context, object *Cluster) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) DeleteCluster(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// ClusterAccountTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterAccountTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterAccountTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccountTemplateList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterAccountTemplate
}

func (ClusterAccountTemplate) NewStatus() interface{} {
	return ClusterAccountTemplateStatus{}
}

func (pc *ClusterAccountTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterAccountTemplate) SetStatus(s interface{}) {
	pc.Status = s.(ClusterAccountTemplateStatus)
}

func (pc *ClusterAccountTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterAccountTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterAccountTemplateSpec)
}

func (pc *ClusterAccountTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterAccountTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterAccountTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterAccountTemplate.
// +k8s:deepcopy-gen=false
type ClusterAccountTemplateRegistry interface {
	ListClusterAccountTemplates(ctx context.Context, options *internalversion.ListOptions) (*ClusterAccountTemplateList, error)
	GetClusterAccountTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterAccountTemplate, error)
	CreateClusterAccountTemplate(ctx context.Context, id *ClusterAccountTemplate) (*ClusterAccountTemplate, error)
	UpdateClusterAccountTemplate(ctx context.Context, id *ClusterAccountTemplate) (*ClusterAccountTemplate, error)
	DeleteClusterAccountTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterAccountTemplateRegistry(sp builders.StandardStorageProvider) ClusterAccountTemplateRegistry {
	return &storageClusterAccountTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterAccountTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageClusterAccountTemplate) ListClusterAccountTemplates(ctx context.Context, options *internalversion.ListOptions) (*ClusterAccountTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccountTemplateList), err
}

func (s *storageClusterAccountTemplate) GetClusterAccountTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterAccountTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccountTemplate), nil
}

func (s *storageClusterAccountTemplate) CreateClusterAccountTemplate(ctx context.Context, object *ClusterAccountTemplate) (*ClusterAccountTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccountTemplate), nil
}

func (s *storageClusterAccountTemplate) UpdateClusterAccountTemplate(ctx context.Context, object *ClusterAccountTemplate) (*ClusterAccountTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccountTemplate), nil
}

func (s *storageClusterAccountTemplate) DeleteClusterAccountTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// ClusterConnect Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterConnectStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterConnectStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterConnectList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterConnect
}

func (ClusterConnect) NewStatus() interface{} {
	return ClusterConnectStatus{}
}

func (pc *ClusterConnect) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterConnect) SetStatus(s interface{}) {
	pc.Status = s.(ClusterConnectStatus)
}

func (pc *ClusterConnect) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterConnect) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterConnectSpec)
}

func (pc *ClusterConnect) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterConnect) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterConnect) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterConnect.
// +k8s:deepcopy-gen=false
type ClusterConnectRegistry interface {
	ListClusterConnects(ctx context.Context, options *internalversion.ListOptions) (*ClusterConnectList, error)
	GetClusterConnect(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterConnect, error)
	CreateClusterConnect(ctx context.Context, id *ClusterConnect) (*ClusterConnect, error)
	UpdateClusterConnect(ctx context.Context, id *ClusterConnect) (*ClusterConnect, error)
	DeleteClusterConnect(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterConnectRegistry(sp builders.StandardStorageProvider) ClusterConnectRegistry {
	return &storageClusterConnect{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterConnect struct {
	builders.StandardStorageProvider
}

func (s *storageClusterConnect) ListClusterConnects(ctx context.Context, options *internalversion.ListOptions) (*ClusterConnectList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnectList), err
}

func (s *storageClusterConnect) GetClusterConnect(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) CreateClusterConnect(ctx context.Context, object *ClusterConnect) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) UpdateClusterConnect(ctx context.Context, object *ClusterConnect) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) DeleteClusterConnect(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Config Functions and Structs
//
// +k8s:deepcopy-gen=false
type ConfigStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ConfigStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ConfigList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Config
}

func (Config) NewStatus() interface{} {
	return ConfigStatus{}
}

func (pc *Config) GetStatus() interface{} {
	return pc.Status
}

func (pc *Config) SetStatus(s interface{}) {
	pc.Status = s.(ConfigStatus)
}

func (pc *Config) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Config) SetSpec(s interface{}) {
	pc.Spec = s.(ConfigSpec)
}

func (pc *Config) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Config) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Config) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Config.
// +k8s:deepcopy-gen=false
type ConfigRegistry interface {
	ListConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConfigList, error)
	GetConfig(ctx context.Context, id string, options *metav1.GetOptions) (*Config, error)
	CreateConfig(ctx context.Context, id *Config) (*Config, error)
	UpdateConfig(ctx context.Context, id *Config) (*Config, error)
	DeleteConfig(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewConfigRegistry(sp builders.StandardStorageProvider) ConfigRegistry {
	return &storageConfig{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageConfig struct {
	builders.StandardStorageProvider
}

func (s *storageConfig) ListConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConfigList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ConfigList), err
}

func (s *storageConfig) GetConfig(ctx context.Context, id string, options *metav1.GetOptions) (*Config, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) CreateConfig(ctx context.Context, object *Config) (*Config, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) UpdateConfig(ctx context.Context, object *Config) (*Config, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) DeleteConfig(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// DirectClusterEndpointToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DirectClusterEndpointTokenList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DirectClusterEndpointToken
}

func (DirectClusterEndpointToken) NewStatus() interface{} {
	return DirectClusterEndpointTokenStatus{}
}

func (pc *DirectClusterEndpointToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *DirectClusterEndpointToken) SetStatus(s interface{}) {
	pc.Status = s.(DirectClusterEndpointTokenStatus)
}

func (pc *DirectClusterEndpointToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DirectClusterEndpointToken) SetSpec(s interface{}) {
	pc.Spec = s.(DirectClusterEndpointTokenSpec)
}

func (pc *DirectClusterEndpointToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DirectClusterEndpointToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DirectClusterEndpointToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DirectClusterEndpointToken.
// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenRegistry interface {
	ListDirectClusterEndpointTokens(ctx context.Context, options *internalversion.ListOptions) (*DirectClusterEndpointTokenList, error)
	GetDirectClusterEndpointToken(ctx context.Context, id string, options *metav1.GetOptions) (*DirectClusterEndpointToken, error)
	CreateDirectClusterEndpointToken(ctx context.Context, id *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error)
	UpdateDirectClusterEndpointToken(ctx context.Context, id *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error)
	DeleteDirectClusterEndpointToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDirectClusterEndpointTokenRegistry(sp builders.StandardStorageProvider) DirectClusterEndpointTokenRegistry {
	return &storageDirectClusterEndpointToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDirectClusterEndpointToken struct {
	builders.StandardStorageProvider
}

func (s *storageDirectClusterEndpointToken) ListDirectClusterEndpointTokens(ctx context.Context, options *internalversion.ListOptions) (*DirectClusterEndpointTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointTokenList), err
}

func (s *storageDirectClusterEndpointToken) GetDirectClusterEndpointToken(ctx context.Context, id string, options *metav1.GetOptions) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) CreateDirectClusterEndpointToken(ctx context.Context, object *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) UpdateDirectClusterEndpointToken(ctx context.Context, object *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) DeleteDirectClusterEndpointToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Event Functions and Structs
//
// +k8s:deepcopy-gen=false
type EventStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type EventStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type EventList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Event
}

func (Event) NewStatus() interface{} {
	return EventStatus{}
}

func (pc *Event) GetStatus() interface{} {
	return pc.Status
}

func (pc *Event) SetStatus(s interface{}) {
	pc.Status = s.(EventStatus)
}

func (pc *Event) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Event) SetSpec(s interface{}) {
	pc.Spec = s.(EventSpec)
}

func (pc *Event) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Event) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Event) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Event.
// +k8s:deepcopy-gen=false
type EventRegistry interface {
	ListEvents(ctx context.Context, options *internalversion.ListOptions) (*EventList, error)
	GetEvent(ctx context.Context, id string, options *metav1.GetOptions) (*Event, error)
	CreateEvent(ctx context.Context, id *Event) (*Event, error)
	UpdateEvent(ctx context.Context, id *Event) (*Event, error)
	DeleteEvent(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewEventRegistry(sp builders.StandardStorageProvider) EventRegistry {
	return &storageEvent{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageEvent struct {
	builders.StandardStorageProvider
}

func (s *storageEvent) ListEvents(ctx context.Context, options *internalversion.ListOptions) (*EventList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*EventList), err
}

func (s *storageEvent) GetEvent(ctx context.Context, id string, options *metav1.GetOptions) (*Event, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) CreateEvent(ctx context.Context, object *Event) (*Event, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) UpdateEvent(ctx context.Context, object *Event) (*Event, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) DeleteEvent(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Feature Functions and Structs
//
// +k8s:deepcopy-gen=false
type FeatureStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type FeatureStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type FeatureList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Feature
}

func (Feature) NewStatus() interface{} {
	return FeatureStatus{}
}

func (pc *Feature) GetStatus() interface{} {
	return pc.Status
}

func (pc *Feature) SetStatus(s interface{}) {
	pc.Status = s.(FeatureStatus)
}

func (pc *Feature) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Feature) SetSpec(s interface{}) {
	pc.Spec = s.(FeatureSpec)
}

func (pc *Feature) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Feature) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Feature) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Feature.
// +k8s:deepcopy-gen=false
type FeatureRegistry interface {
	ListFeatures(ctx context.Context, options *internalversion.ListOptions) (*FeatureList, error)
	GetFeature(ctx context.Context, id string, options *metav1.GetOptions) (*Feature, error)
	CreateFeature(ctx context.Context, id *Feature) (*Feature, error)
	UpdateFeature(ctx context.Context, id *Feature) (*Feature, error)
	DeleteFeature(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewFeatureRegistry(sp builders.StandardStorageProvider) FeatureRegistry {
	return &storageFeature{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageFeature struct {
	builders.StandardStorageProvider
}

func (s *storageFeature) ListFeatures(ctx context.Context, options *internalversion.ListOptions) (*FeatureList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*FeatureList), err
}

func (s *storageFeature) GetFeature(ctx context.Context, id string, options *metav1.GetOptions) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) CreateFeature(ctx context.Context, object *Feature) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) UpdateFeature(ctx context.Context, object *Feature) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) DeleteFeature(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// GlobalClusterAccess Functions and Structs
//
// +k8s:deepcopy-gen=false
type GlobalClusterAccessStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type GlobalClusterAccessStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type GlobalClusterAccessList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []GlobalClusterAccess
}

func (GlobalClusterAccess) NewStatus() interface{} {
	return GlobalClusterAccessStatus{}
}

func (pc *GlobalClusterAccess) GetStatus() interface{} {
	return pc.Status
}

func (pc *GlobalClusterAccess) SetStatus(s interface{}) {
	pc.Status = s.(GlobalClusterAccessStatus)
}

func (pc *GlobalClusterAccess) GetSpec() interface{} {
	return pc.Spec
}

func (pc *GlobalClusterAccess) SetSpec(s interface{}) {
	pc.Spec = s.(GlobalClusterAccessSpec)
}

func (pc *GlobalClusterAccess) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *GlobalClusterAccess) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc GlobalClusterAccess) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store GlobalClusterAccess.
// +k8s:deepcopy-gen=false
type GlobalClusterAccessRegistry interface {
	ListGlobalClusterAccesss(ctx context.Context, options *internalversion.ListOptions) (*GlobalClusterAccessList, error)
	GetGlobalClusterAccess(ctx context.Context, id string, options *metav1.GetOptions) (*GlobalClusterAccess, error)
	CreateGlobalClusterAccess(ctx context.Context, id *GlobalClusterAccess) (*GlobalClusterAccess, error)
	UpdateGlobalClusterAccess(ctx context.Context, id *GlobalClusterAccess) (*GlobalClusterAccess, error)
	DeleteGlobalClusterAccess(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewGlobalClusterAccessRegistry(sp builders.StandardStorageProvider) GlobalClusterAccessRegistry {
	return &storageGlobalClusterAccess{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageGlobalClusterAccess struct {
	builders.StandardStorageProvider
}

func (s *storageGlobalClusterAccess) ListGlobalClusterAccesss(ctx context.Context, options *internalversion.ListOptions) (*GlobalClusterAccessList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalClusterAccessList), err
}

func (s *storageGlobalClusterAccess) GetGlobalClusterAccess(ctx context.Context, id string, options *metav1.GetOptions) (*GlobalClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalClusterAccess), nil
}

func (s *storageGlobalClusterAccess) CreateGlobalClusterAccess(ctx context.Context, object *GlobalClusterAccess) (*GlobalClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalClusterAccess), nil
}

func (s *storageGlobalClusterAccess) UpdateGlobalClusterAccess(ctx context.Context, object *GlobalClusterAccess) (*GlobalClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalClusterAccess), nil
}

func (s *storageGlobalClusterAccess) DeleteGlobalClusterAccess(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// GlobalClusterRoleTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type GlobalClusterRoleTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type GlobalClusterRoleTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type GlobalClusterRoleTemplateList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []GlobalClusterRoleTemplate
}

func (GlobalClusterRoleTemplate) NewStatus() interface{} {
	return GlobalClusterRoleTemplateStatus{}
}

func (pc *GlobalClusterRoleTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *GlobalClusterRoleTemplate) SetStatus(s interface{}) {
	pc.Status = s.(GlobalClusterRoleTemplateStatus)
}

func (pc *GlobalClusterRoleTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *GlobalClusterRoleTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(GlobalClusterRoleTemplateSpec)
}

func (pc *GlobalClusterRoleTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *GlobalClusterRoleTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc GlobalClusterRoleTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store GlobalClusterRoleTemplate.
// +k8s:deepcopy-gen=false
type GlobalClusterRoleTemplateRegistry interface {
	ListGlobalClusterRoleTemplates(ctx context.Context, options *internalversion.ListOptions) (*GlobalClusterRoleTemplateList, error)
	GetGlobalClusterRoleTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*GlobalClusterRoleTemplate, error)
	CreateGlobalClusterRoleTemplate(ctx context.Context, id *GlobalClusterRoleTemplate) (*GlobalClusterRoleTemplate, error)
	UpdateGlobalClusterRoleTemplate(ctx context.Context, id *GlobalClusterRoleTemplate) (*GlobalClusterRoleTemplate, error)
	DeleteGlobalClusterRoleTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewGlobalClusterRoleTemplateRegistry(sp builders.StandardStorageProvider) GlobalClusterRoleTemplateRegistry {
	return &storageGlobalClusterRoleTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageGlobalClusterRoleTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageGlobalClusterRoleTemplate) ListGlobalClusterRoleTemplates(ctx context.Context, options *internalversion.ListOptions) (*GlobalClusterRoleTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalClusterRoleTemplateList), err
}

func (s *storageGlobalClusterRoleTemplate) GetGlobalClusterRoleTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*GlobalClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalClusterRoleTemplate), nil
}

func (s *storageGlobalClusterRoleTemplate) CreateGlobalClusterRoleTemplate(ctx context.Context, object *GlobalClusterRoleTemplate) (*GlobalClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalClusterRoleTemplate), nil
}

func (s *storageGlobalClusterRoleTemplate) UpdateGlobalClusterRoleTemplate(ctx context.Context, object *GlobalClusterRoleTemplate) (*GlobalClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalClusterRoleTemplate), nil
}

func (s *storageGlobalClusterRoleTemplate) DeleteGlobalClusterRoleTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// GlobalSpaceConstraint Functions and Structs
//
// +k8s:deepcopy-gen=false
type GlobalSpaceConstraintStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type GlobalSpaceConstraintStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type GlobalSpaceConstraintList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []GlobalSpaceConstraint
}

func (GlobalSpaceConstraint) NewStatus() interface{} {
	return GlobalSpaceConstraintStatus{}
}

func (pc *GlobalSpaceConstraint) GetStatus() interface{} {
	return pc.Status
}

func (pc *GlobalSpaceConstraint) SetStatus(s interface{}) {
	pc.Status = s.(GlobalSpaceConstraintStatus)
}

func (pc *GlobalSpaceConstraint) GetSpec() interface{} {
	return pc.Spec
}

func (pc *GlobalSpaceConstraint) SetSpec(s interface{}) {
	pc.Spec = s.(GlobalSpaceConstraintSpec)
}

func (pc *GlobalSpaceConstraint) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *GlobalSpaceConstraint) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc GlobalSpaceConstraint) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store GlobalSpaceConstraint.
// +k8s:deepcopy-gen=false
type GlobalSpaceConstraintRegistry interface {
	ListGlobalSpaceConstraints(ctx context.Context, options *internalversion.ListOptions) (*GlobalSpaceConstraintList, error)
	GetGlobalSpaceConstraint(ctx context.Context, id string, options *metav1.GetOptions) (*GlobalSpaceConstraint, error)
	CreateGlobalSpaceConstraint(ctx context.Context, id *GlobalSpaceConstraint) (*GlobalSpaceConstraint, error)
	UpdateGlobalSpaceConstraint(ctx context.Context, id *GlobalSpaceConstraint) (*GlobalSpaceConstraint, error)
	DeleteGlobalSpaceConstraint(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewGlobalSpaceConstraintRegistry(sp builders.StandardStorageProvider) GlobalSpaceConstraintRegistry {
	return &storageGlobalSpaceConstraint{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageGlobalSpaceConstraint struct {
	builders.StandardStorageProvider
}

func (s *storageGlobalSpaceConstraint) ListGlobalSpaceConstraints(ctx context.Context, options *internalversion.ListOptions) (*GlobalSpaceConstraintList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalSpaceConstraintList), err
}

func (s *storageGlobalSpaceConstraint) GetGlobalSpaceConstraint(ctx context.Context, id string, options *metav1.GetOptions) (*GlobalSpaceConstraint, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalSpaceConstraint), nil
}

func (s *storageGlobalSpaceConstraint) CreateGlobalSpaceConstraint(ctx context.Context, object *GlobalSpaceConstraint) (*GlobalSpaceConstraint, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalSpaceConstraint), nil
}

func (s *storageGlobalSpaceConstraint) UpdateGlobalSpaceConstraint(ctx context.Context, object *GlobalSpaceConstraint) (*GlobalSpaceConstraint, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*GlobalSpaceConstraint), nil
}

func (s *storageGlobalSpaceConstraint) DeleteGlobalSpaceConstraint(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Kiosk Functions and Structs
//
// +k8s:deepcopy-gen=false
type KioskStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type KioskStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type KioskList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Kiosk
}

func (Kiosk) NewStatus() interface{} {
	return KioskStatus{}
}

func (pc *Kiosk) GetStatus() interface{} {
	return pc.Status
}

func (pc *Kiosk) SetStatus(s interface{}) {
	pc.Status = s.(KioskStatus)
}

func (pc *Kiosk) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Kiosk) SetSpec(s interface{}) {
	pc.Spec = s.(KioskSpec)
}

func (pc *Kiosk) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Kiosk) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Kiosk) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Kiosk.
// +k8s:deepcopy-gen=false
type KioskRegistry interface {
	ListKiosks(ctx context.Context, options *internalversion.ListOptions) (*KioskList, error)
	GetKiosk(ctx context.Context, id string, options *metav1.GetOptions) (*Kiosk, error)
	CreateKiosk(ctx context.Context, id *Kiosk) (*Kiosk, error)
	UpdateKiosk(ctx context.Context, id *Kiosk) (*Kiosk, error)
	DeleteKiosk(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewKioskRegistry(sp builders.StandardStorageProvider) KioskRegistry {
	return &storageKiosk{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageKiosk struct {
	builders.StandardStorageProvider
}

func (s *storageKiosk) ListKiosks(ctx context.Context, options *internalversion.ListOptions) (*KioskList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*KioskList), err
}

func (s *storageKiosk) GetKiosk(ctx context.Context, id string, options *metav1.GetOptions) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) CreateKiosk(ctx context.Context, object *Kiosk) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) UpdateKiosk(ctx context.Context, object *Kiosk) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) DeleteKiosk(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// License Functions and Structs
//
// +k8s:deepcopy-gen=false
type LicenseStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LicenseStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []License
}

func (License) NewStatus() interface{} {
	return LicenseStatus{}
}

func (pc *License) GetStatus() interface{} {
	return pc.Status
}

func (pc *License) SetStatus(s interface{}) {
	pc.Status = s.(LicenseStatus)
}

func (pc *License) GetSpec() interface{} {
	return pc.Spec
}

func (pc *License) SetSpec(s interface{}) {
	pc.Spec = s.(LicenseSpec)
}

func (pc *License) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *License) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc License) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store License.
// +k8s:deepcopy-gen=false
type LicenseRegistry interface {
	ListLicenses(ctx context.Context, options *internalversion.ListOptions) (*LicenseList, error)
	GetLicense(ctx context.Context, id string, options *metav1.GetOptions) (*License, error)
	CreateLicense(ctx context.Context, id *License) (*License, error)
	UpdateLicense(ctx context.Context, id *License) (*License, error)
	DeleteLicense(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLicenseRegistry(sp builders.StandardStorageProvider) LicenseRegistry {
	return &storageLicense{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLicense struct {
	builders.StandardStorageProvider
}

func (s *storageLicense) ListLicenses(ctx context.Context, options *internalversion.ListOptions) (*LicenseList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseList), err
}

func (s *storageLicense) GetLicense(ctx context.Context, id string, options *metav1.GetOptions) (*License, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) CreateLicense(ctx context.Context, object *License) (*License, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) UpdateLicense(ctx context.Context, object *License) (*License, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) DeleteLicense(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// LicenseToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type LicenseTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LicenseTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseTokenList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []LicenseToken
}

func (LicenseToken) NewStatus() interface{} {
	return LicenseTokenStatus{}
}

func (pc *LicenseToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *LicenseToken) SetStatus(s interface{}) {
	pc.Status = s.(LicenseTokenStatus)
}

func (pc *LicenseToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *LicenseToken) SetSpec(s interface{}) {
	pc.Spec = s.(LicenseTokenSpec)
}

func (pc *LicenseToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *LicenseToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc LicenseToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store LicenseToken.
// +k8s:deepcopy-gen=false
type LicenseTokenRegistry interface {
	ListLicenseTokens(ctx context.Context, options *internalversion.ListOptions) (*LicenseTokenList, error)
	GetLicenseToken(ctx context.Context, id string, options *metav1.GetOptions) (*LicenseToken, error)
	CreateLicenseToken(ctx context.Context, id *LicenseToken) (*LicenseToken, error)
	UpdateLicenseToken(ctx context.Context, id *LicenseToken) (*LicenseToken, error)
	DeleteLicenseToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLicenseTokenRegistry(sp builders.StandardStorageProvider) LicenseTokenRegistry {
	return &storageLicenseToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLicenseToken struct {
	builders.StandardStorageProvider
}

func (s *storageLicenseToken) ListLicenseTokens(ctx context.Context, options *internalversion.ListOptions) (*LicenseTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseTokenList), err
}

func (s *storageLicenseToken) GetLicenseToken(ctx context.Context, id string, options *metav1.GetOptions) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) CreateLicenseToken(ctx context.Context, object *LicenseToken) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) UpdateLicenseToken(ctx context.Context, object *LicenseToken) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) DeleteLicenseToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// LoftUpgrade Functions and Structs
//
// +k8s:deepcopy-gen=false
type LoftUpgradeStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LoftUpgradeStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LoftUpgradeList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []LoftUpgrade
}

func (LoftUpgrade) NewStatus() interface{} {
	return LoftUpgradeStatus{}
}

func (pc *LoftUpgrade) GetStatus() interface{} {
	return pc.Status
}

func (pc *LoftUpgrade) SetStatus(s interface{}) {
	pc.Status = s.(LoftUpgradeStatus)
}

func (pc *LoftUpgrade) GetSpec() interface{} {
	return pc.Spec
}

func (pc *LoftUpgrade) SetSpec(s interface{}) {
	pc.Spec = s.(LoftUpgradeSpec)
}

func (pc *LoftUpgrade) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *LoftUpgrade) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc LoftUpgrade) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store LoftUpgrade.
// +k8s:deepcopy-gen=false
type LoftUpgradeRegistry interface {
	ListLoftUpgrades(ctx context.Context, options *internalversion.ListOptions) (*LoftUpgradeList, error)
	GetLoftUpgrade(ctx context.Context, id string, options *metav1.GetOptions) (*LoftUpgrade, error)
	CreateLoftUpgrade(ctx context.Context, id *LoftUpgrade) (*LoftUpgrade, error)
	UpdateLoftUpgrade(ctx context.Context, id *LoftUpgrade) (*LoftUpgrade, error)
	DeleteLoftUpgrade(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLoftUpgradeRegistry(sp builders.StandardStorageProvider) LoftUpgradeRegistry {
	return &storageLoftUpgrade{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLoftUpgrade struct {
	builders.StandardStorageProvider
}

func (s *storageLoftUpgrade) ListLoftUpgrades(ctx context.Context, options *internalversion.ListOptions) (*LoftUpgradeList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgradeList), err
}

func (s *storageLoftUpgrade) GetLoftUpgrade(ctx context.Context, id string, options *metav1.GetOptions) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) CreateLoftUpgrade(ctx context.Context, object *LoftUpgrade) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) UpdateLoftUpgrade(ctx context.Context, object *LoftUpgrade) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) DeleteLoftUpgrade(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// OwnedAccessKey Functions and Structs
//
// +k8s:deepcopy-gen=false
type OwnedAccessKeyStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type OwnedAccessKeyStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type OwnedAccessKeyList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []OwnedAccessKey
}

func (OwnedAccessKey) NewStatus() interface{} {
	return OwnedAccessKeyStatus{}
}

func (pc *OwnedAccessKey) GetStatus() interface{} {
	return pc.Status
}

func (pc *OwnedAccessKey) SetStatus(s interface{}) {
	pc.Status = s.(OwnedAccessKeyStatus)
}

func (pc *OwnedAccessKey) GetSpec() interface{} {
	return pc.Spec
}

func (pc *OwnedAccessKey) SetSpec(s interface{}) {
	pc.Spec = s.(OwnedAccessKeySpec)
}

func (pc *OwnedAccessKey) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *OwnedAccessKey) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc OwnedAccessKey) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store OwnedAccessKey.
// +k8s:deepcopy-gen=false
type OwnedAccessKeyRegistry interface {
	ListOwnedAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*OwnedAccessKeyList, error)
	GetOwnedAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*OwnedAccessKey, error)
	CreateOwnedAccessKey(ctx context.Context, id *OwnedAccessKey) (*OwnedAccessKey, error)
	UpdateOwnedAccessKey(ctx context.Context, id *OwnedAccessKey) (*OwnedAccessKey, error)
	DeleteOwnedAccessKey(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewOwnedAccessKeyRegistry(sp builders.StandardStorageProvider) OwnedAccessKeyRegistry {
	return &storageOwnedAccessKey{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageOwnedAccessKey struct {
	builders.StandardStorageProvider
}

func (s *storageOwnedAccessKey) ListOwnedAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*OwnedAccessKeyList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKeyList), err
}

func (s *storageOwnedAccessKey) GetOwnedAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) CreateOwnedAccessKey(ctx context.Context, object *OwnedAccessKey) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) UpdateOwnedAccessKey(ctx context.Context, object *OwnedAccessKey) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) DeleteOwnedAccessKey(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// PolicyViolation Functions and Structs
//
// +k8s:deepcopy-gen=false
type PolicyViolationStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type PolicyViolationStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type PolicyViolationList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []PolicyViolation
}

func (PolicyViolation) NewStatus() interface{} {
	return PolicyViolationStatus{}
}

func (pc *PolicyViolation) GetStatus() interface{} {
	return pc.Status
}

func (pc *PolicyViolation) SetStatus(s interface{}) {
	pc.Status = s.(PolicyViolationStatus)
}

func (pc *PolicyViolation) GetSpec() interface{} {
	return pc.Spec
}

func (pc *PolicyViolation) SetSpec(s interface{}) {
	pc.Spec = s.(PolicyViolationSpec)
}

func (pc *PolicyViolation) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *PolicyViolation) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc PolicyViolation) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store PolicyViolation.
// +k8s:deepcopy-gen=false
type PolicyViolationRegistry interface {
	ListPolicyViolations(ctx context.Context, options *internalversion.ListOptions) (*PolicyViolationList, error)
	GetPolicyViolation(ctx context.Context, id string, options *metav1.GetOptions) (*PolicyViolation, error)
	CreatePolicyViolation(ctx context.Context, id *PolicyViolation) (*PolicyViolation, error)
	UpdatePolicyViolation(ctx context.Context, id *PolicyViolation) (*PolicyViolation, error)
	DeletePolicyViolation(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewPolicyViolationRegistry(sp builders.StandardStorageProvider) PolicyViolationRegistry {
	return &storagePolicyViolation{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storagePolicyViolation struct {
	builders.StandardStorageProvider
}

func (s *storagePolicyViolation) ListPolicyViolations(ctx context.Context, options *internalversion.ListOptions) (*PolicyViolationList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*PolicyViolationList), err
}

func (s *storagePolicyViolation) GetPolicyViolation(ctx context.Context, id string, options *metav1.GetOptions) (*PolicyViolation, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*PolicyViolation), nil
}

func (s *storagePolicyViolation) CreatePolicyViolation(ctx context.Context, object *PolicyViolation) (*PolicyViolation, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*PolicyViolation), nil
}

func (s *storagePolicyViolation) UpdatePolicyViolation(ctx context.Context, object *PolicyViolation) (*PolicyViolation, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*PolicyViolation), nil
}

func (s *storagePolicyViolation) DeletePolicyViolation(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// ResetAccessKey Functions and Structs
//
// +k8s:deepcopy-gen=false
type ResetAccessKeyStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ResetAccessKeyStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ResetAccessKeyList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ResetAccessKey
}

func (ResetAccessKey) NewStatus() interface{} {
	return ResetAccessKeyStatus{}
}

func (pc *ResetAccessKey) GetStatus() interface{} {
	return pc.Status
}

func (pc *ResetAccessKey) SetStatus(s interface{}) {
	pc.Status = s.(ResetAccessKeyStatus)
}

func (pc *ResetAccessKey) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ResetAccessKey) SetSpec(s interface{}) {
	pc.Spec = s.(ResetAccessKeySpec)
}

func (pc *ResetAccessKey) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ResetAccessKey) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ResetAccessKey) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ResetAccessKey.
// +k8s:deepcopy-gen=false
type ResetAccessKeyRegistry interface {
	ListResetAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*ResetAccessKeyList, error)
	GetResetAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*ResetAccessKey, error)
	CreateResetAccessKey(ctx context.Context, id *ResetAccessKey) (*ResetAccessKey, error)
	UpdateResetAccessKey(ctx context.Context, id *ResetAccessKey) (*ResetAccessKey, error)
	DeleteResetAccessKey(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewResetAccessKeyRegistry(sp builders.StandardStorageProvider) ResetAccessKeyRegistry {
	return &storageResetAccessKey{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageResetAccessKey struct {
	builders.StandardStorageProvider
}

func (s *storageResetAccessKey) ListResetAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*ResetAccessKeyList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKeyList), err
}

func (s *storageResetAccessKey) GetResetAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) CreateResetAccessKey(ctx context.Context, object *ResetAccessKey) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) UpdateResetAccessKey(ctx context.Context, object *ResetAccessKey) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) DeleteResetAccessKey(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Self Functions and Structs
//
// +k8s:deepcopy-gen=false
type SelfStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SelfStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Self
}

func (Self) NewStatus() interface{} {
	return SelfStatus{}
}

func (pc *Self) GetStatus() interface{} {
	return pc.Status
}

func (pc *Self) SetStatus(s interface{}) {
	pc.Status = s.(SelfStatus)
}

func (pc *Self) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Self) SetSpec(s interface{}) {
	pc.Spec = s.(SelfSpec)
}

func (pc *Self) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Self) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Self) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Self.
// +k8s:deepcopy-gen=false
type SelfRegistry interface {
	ListSelfs(ctx context.Context, options *internalversion.ListOptions) (*SelfList, error)
	GetSelf(ctx context.Context, id string, options *metav1.GetOptions) (*Self, error)
	CreateSelf(ctx context.Context, id *Self) (*Self, error)
	UpdateSelf(ctx context.Context, id *Self) (*Self, error)
	DeleteSelf(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSelfRegistry(sp builders.StandardStorageProvider) SelfRegistry {
	return &storageSelf{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSelf struct {
	builders.StandardStorageProvider
}

func (s *storageSelf) ListSelfs(ctx context.Context, options *internalversion.ListOptions) (*SelfList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfList), err
}

func (s *storageSelf) GetSelf(ctx context.Context, id string, options *metav1.GetOptions) (*Self, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) CreateSelf(ctx context.Context, object *Self) (*Self, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) UpdateSelf(ctx context.Context, object *Self) (*Self, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) DeleteSelf(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// SelfSubjectAccessReview Functions and Structs
//
// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfSubjectAccessReviewList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SelfSubjectAccessReview
}

func (SelfSubjectAccessReview) NewStatus() interface{} {
	return SelfSubjectAccessReviewStatus{}
}

func (pc *SelfSubjectAccessReview) GetStatus() interface{} {
	return pc.Status
}

func (pc *SelfSubjectAccessReview) SetStatus(s interface{}) {
	pc.Status = s.(SelfSubjectAccessReviewStatus)
}

func (pc *SelfSubjectAccessReview) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SelfSubjectAccessReview) SetSpec(s interface{}) {
	pc.Spec = s.(SelfSubjectAccessReviewSpec)
}

func (pc *SelfSubjectAccessReview) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SelfSubjectAccessReview) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SelfSubjectAccessReview) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SelfSubjectAccessReview.
// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewRegistry interface {
	ListSelfSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SelfSubjectAccessReviewList, error)
	GetSelfSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SelfSubjectAccessReview, error)
	CreateSelfSubjectAccessReview(ctx context.Context, id *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error)
	UpdateSelfSubjectAccessReview(ctx context.Context, id *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error)
	DeleteSelfSubjectAccessReview(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSelfSubjectAccessReviewRegistry(sp builders.StandardStorageProvider) SelfSubjectAccessReviewRegistry {
	return &storageSelfSubjectAccessReview{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSelfSubjectAccessReview struct {
	builders.StandardStorageProvider
}

func (s *storageSelfSubjectAccessReview) ListSelfSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SelfSubjectAccessReviewList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReviewList), err
}

func (s *storageSelfSubjectAccessReview) GetSelfSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) CreateSelfSubjectAccessReview(ctx context.Context, object *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) UpdateSelfSubjectAccessReview(ctx context.Context, object *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) DeleteSelfSubjectAccessReview(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// SharedSecret Functions and Structs
//
// +k8s:deepcopy-gen=false
type SharedSecretStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SharedSecretStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SharedSecretList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SharedSecret
}

func (SharedSecret) NewStatus() interface{} {
	return SharedSecretStatus{}
}

func (pc *SharedSecret) GetStatus() interface{} {
	return pc.Status
}

func (pc *SharedSecret) SetStatus(s interface{}) {
	pc.Status = s.(SharedSecretStatus)
}

func (pc *SharedSecret) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SharedSecret) SetSpec(s interface{}) {
	pc.Spec = s.(SharedSecretSpec)
}

func (pc *SharedSecret) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SharedSecret) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SharedSecret) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SharedSecret.
// +k8s:deepcopy-gen=false
type SharedSecretRegistry interface {
	ListSharedSecrets(ctx context.Context, options *internalversion.ListOptions) (*SharedSecretList, error)
	GetSharedSecret(ctx context.Context, id string, options *metav1.GetOptions) (*SharedSecret, error)
	CreateSharedSecret(ctx context.Context, id *SharedSecret) (*SharedSecret, error)
	UpdateSharedSecret(ctx context.Context, id *SharedSecret) (*SharedSecret, error)
	DeleteSharedSecret(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSharedSecretRegistry(sp builders.StandardStorageProvider) SharedSecretRegistry {
	return &storageSharedSecret{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSharedSecret struct {
	builders.StandardStorageProvider
}

func (s *storageSharedSecret) ListSharedSecrets(ctx context.Context, options *internalversion.ListOptions) (*SharedSecretList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecretList), err
}

func (s *storageSharedSecret) GetSharedSecret(ctx context.Context, id string, options *metav1.GetOptions) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) CreateSharedSecret(ctx context.Context, object *SharedSecret) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) UpdateSharedSecret(ctx context.Context, object *SharedSecret) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) DeleteSharedSecret(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// SpaceTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type SpaceTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SpaceTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceTemplateList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SpaceTemplate
}

func (SpaceTemplate) NewStatus() interface{} {
	return SpaceTemplateStatus{}
}

func (pc *SpaceTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *SpaceTemplate) SetStatus(s interface{}) {
	pc.Status = s.(SpaceTemplateStatus)
}

func (pc *SpaceTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SpaceTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(SpaceTemplateSpec)
}

func (pc *SpaceTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SpaceTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SpaceTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SpaceTemplate.
// +k8s:deepcopy-gen=false
type SpaceTemplateRegistry interface {
	ListSpaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*SpaceTemplateList, error)
	GetSpaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceTemplate, error)
	CreateSpaceTemplate(ctx context.Context, id *SpaceTemplate) (*SpaceTemplate, error)
	UpdateSpaceTemplate(ctx context.Context, id *SpaceTemplate) (*SpaceTemplate, error)
	DeleteSpaceTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSpaceTemplateRegistry(sp builders.StandardStorageProvider) SpaceTemplateRegistry {
	return &storageSpaceTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSpaceTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageSpaceTemplate) ListSpaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*SpaceTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplateList), err
}

func (s *storageSpaceTemplate) GetSpaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) CreateSpaceTemplate(ctx context.Context, object *SpaceTemplate) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) UpdateSpaceTemplate(ctx context.Context, object *SpaceTemplate) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) DeleteSpaceTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// SubjectAccessReview Functions and Structs
//
// +k8s:deepcopy-gen=false
type SubjectAccessReviewStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SubjectAccessReviewStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SubjectAccessReviewList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SubjectAccessReview
}

func (SubjectAccessReview) NewStatus() interface{} {
	return SubjectAccessReviewStatus{}
}

func (pc *SubjectAccessReview) GetStatus() interface{} {
	return pc.Status
}

func (pc *SubjectAccessReview) SetStatus(s interface{}) {
	pc.Status = s.(SubjectAccessReviewStatus)
}

func (pc *SubjectAccessReview) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SubjectAccessReview) SetSpec(s interface{}) {
	pc.Spec = s.(SubjectAccessReviewSpec)
}

func (pc *SubjectAccessReview) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SubjectAccessReview) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SubjectAccessReview) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SubjectAccessReview.
// +k8s:deepcopy-gen=false
type SubjectAccessReviewRegistry interface {
	ListSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SubjectAccessReviewList, error)
	GetSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SubjectAccessReview, error)
	CreateSubjectAccessReview(ctx context.Context, id *SubjectAccessReview) (*SubjectAccessReview, error)
	UpdateSubjectAccessReview(ctx context.Context, id *SubjectAccessReview) (*SubjectAccessReview, error)
	DeleteSubjectAccessReview(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSubjectAccessReviewRegistry(sp builders.StandardStorageProvider) SubjectAccessReviewRegistry {
	return &storageSubjectAccessReview{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSubjectAccessReview struct {
	builders.StandardStorageProvider
}

func (s *storageSubjectAccessReview) ListSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SubjectAccessReviewList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReviewList), err
}

func (s *storageSubjectAccessReview) GetSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) CreateSubjectAccessReview(ctx context.Context, object *SubjectAccessReview) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) UpdateSubjectAccessReview(ctx context.Context, object *SubjectAccessReview) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) DeleteSubjectAccessReview(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Task Functions and Structs
//
// +k8s:deepcopy-gen=false
type TaskStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type TaskStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Task
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskLogList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TaskLog
}

func (Task) NewStatus() interface{} {
	return TaskStatus{}
}

func (pc *Task) GetStatus() interface{} {
	return pc.Status
}

func (pc *Task) SetStatus(s interface{}) {
	pc.Status = s.(TaskStatus)
}

func (pc *Task) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Task) SetSpec(s interface{}) {
	pc.Spec = s.(TaskSpec)
}

func (pc *Task) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Task) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Task) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Task.
// +k8s:deepcopy-gen=false
type TaskRegistry interface {
	ListTasks(ctx context.Context, options *internalversion.ListOptions) (*TaskList, error)
	GetTask(ctx context.Context, id string, options *metav1.GetOptions) (*Task, error)
	CreateTask(ctx context.Context, id *Task) (*Task, error)
	UpdateTask(ctx context.Context, id *Task) (*Task, error)
	DeleteTask(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewTaskRegistry(sp builders.StandardStorageProvider) TaskRegistry {
	return &storageTask{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageTask struct {
	builders.StandardStorageProvider
}

func (s *storageTask) ListTasks(ctx context.Context, options *internalversion.ListOptions) (*TaskList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TaskList), err
}

func (s *storageTask) GetTask(ctx context.Context, id string, options *metav1.GetOptions) (*Task, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) CreateTask(ctx context.Context, object *Task) (*Task, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) UpdateTask(ctx context.Context, object *Task) (*Task, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) DeleteTask(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// Team Functions and Structs
//
// +k8s:deepcopy-gen=false
type TeamStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type TeamStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Team
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamAccessKeysList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TeamAccessKeys
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClustersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TeamClusters
}

func (Team) NewStatus() interface{} {
	return TeamStatus{}
}

func (pc *Team) GetStatus() interface{} {
	return pc.Status
}

func (pc *Team) SetStatus(s interface{}) {
	pc.Status = s.(TeamStatus)
}

func (pc *Team) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Team) SetSpec(s interface{}) {
	pc.Spec = s.(TeamSpec)
}

func (pc *Team) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Team) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Team) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Team.
// +k8s:deepcopy-gen=false
type TeamRegistry interface {
	ListTeams(ctx context.Context, options *internalversion.ListOptions) (*TeamList, error)
	GetTeam(ctx context.Context, id string, options *metav1.GetOptions) (*Team, error)
	CreateTeam(ctx context.Context, id *Team) (*Team, error)
	UpdateTeam(ctx context.Context, id *Team) (*Team, error)
	DeleteTeam(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewTeamRegistry(sp builders.StandardStorageProvider) TeamRegistry {
	return &storageTeam{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageTeam struct {
	builders.StandardStorageProvider
}

func (s *storageTeam) ListTeams(ctx context.Context, options *internalversion.ListOptions) (*TeamList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TeamList), err
}

func (s *storageTeam) GetTeam(ctx context.Context, id string, options *metav1.GetOptions) (*Team, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) CreateTeam(ctx context.Context, object *Team) (*Team, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) UpdateTeam(ctx context.Context, object *Team) (*Team, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) DeleteTeam(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// User Functions and Structs
//
// +k8s:deepcopy-gen=false
type UserStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type UserStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []User
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserAccessKeysList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserAccessKeys
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClustersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserClusters
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserProfileList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserProfile
}

func (User) NewStatus() interface{} {
	return UserStatus{}
}

func (pc *User) GetStatus() interface{} {
	return pc.Status
}

func (pc *User) SetStatus(s interface{}) {
	pc.Status = s.(UserStatus)
}

func (pc *User) GetSpec() interface{} {
	return pc.Spec
}

func (pc *User) SetSpec(s interface{}) {
	pc.Spec = s.(UserSpec)
}

func (pc *User) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *User) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc User) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store User.
// +k8s:deepcopy-gen=false
type UserRegistry interface {
	ListUsers(ctx context.Context, options *internalversion.ListOptions) (*UserList, error)
	GetUser(ctx context.Context, id string, options *metav1.GetOptions) (*User, error)
	CreateUser(ctx context.Context, id *User) (*User, error)
	UpdateUser(ctx context.Context, id *User) (*User, error)
	DeleteUser(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewUserRegistry(sp builders.StandardStorageProvider) UserRegistry {
	return &storageUser{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageUser struct {
	builders.StandardStorageProvider
}

func (s *storageUser) ListUsers(ctx context.Context, options *internalversion.ListOptions) (*UserList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*UserList), err
}

func (s *storageUser) GetUser(ctx context.Context, id string, options *metav1.GetOptions) (*User, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) CreateUser(ctx context.Context, object *User) (*User, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) UpdateUser(ctx context.Context, object *User) (*User, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) DeleteUser(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// VirtualClusterTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type VirtualClusterTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type VirtualClusterTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterTemplateList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []VirtualClusterTemplate
}

func (VirtualClusterTemplate) NewStatus() interface{} {
	return VirtualClusterTemplateStatus{}
}

func (pc *VirtualClusterTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *VirtualClusterTemplate) SetStatus(s interface{}) {
	pc.Status = s.(VirtualClusterTemplateStatus)
}

func (pc *VirtualClusterTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *VirtualClusterTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(VirtualClusterTemplateSpec)
}

func (pc *VirtualClusterTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *VirtualClusterTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc VirtualClusterTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store VirtualClusterTemplate.
// +k8s:deepcopy-gen=false
type VirtualClusterTemplateRegistry interface {
	ListVirtualClusterTemplates(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterTemplateList, error)
	GetVirtualClusterTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterTemplate, error)
	CreateVirtualClusterTemplate(ctx context.Context, id *VirtualClusterTemplate) (*VirtualClusterTemplate, error)
	UpdateVirtualClusterTemplate(ctx context.Context, id *VirtualClusterTemplate) (*VirtualClusterTemplate, error)
	DeleteVirtualClusterTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewVirtualClusterTemplateRegistry(sp builders.StandardStorageProvider) VirtualClusterTemplateRegistry {
	return &storageVirtualClusterTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageVirtualClusterTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageVirtualClusterTemplate) ListVirtualClusterTemplates(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplateList), err
}

func (s *storageVirtualClusterTemplate) GetVirtualClusterTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) CreateVirtualClusterTemplate(ctx context.Context, object *VirtualClusterTemplate) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) UpdateVirtualClusterTemplate(ctx context.Context, object *VirtualClusterTemplate) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) DeleteVirtualClusterTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}
